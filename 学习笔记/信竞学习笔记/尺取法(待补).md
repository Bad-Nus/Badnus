# 尺取法
尺取法就是像尺子一样，截取一段区间的信息，使用双指针实现。  
## 同向扫描
**例题**：[滑动窗口](https://www.luogu.com.cn/problem/P1886)  
- 暴力:枚举 $1\le \color{red}l\color{balck}\le \color{red}r\color{black}\le n$ 的区间 $[a_l,a_r]$，并寻找符合方案，代码如下:
```cpp
for(int i=1;i<=n;++i){//1~n
		for(int j=i;j<=n;++j){//i~n
			//do sth...
		}
	}	
```
- 尺取法:将两层循环并在同一层使用：

```cpp
for (int i = 1, j = i + 1; i <= j;) {
/*
    do sth...
    if(#Case 1)++i;
    if(#Case 2)++j;
*/
}
```
## 反向扫描
**例题**：[判断回文串](https://www.luogu.com.cn/problem/B2124)  
- 尺取法:两边各放一指针，相同同时内缩：
```cpp
for (int i = 1, j = n; i <= j;) {
/*
    if(ai==aj)++i,--j;
    else break;
*/
}
```
## 复杂度分析
复杂度都从 $\color{red}O(n^2)$ 变为 $\color{green}O(2n)$ 即 $\color{green}O(n)$，可是优化在哪里呢，明明都是 $i,j$ 遍历 $1$ 到 $n$ 且 $i$ 严格小于 $j$，为何复杂度骤降？
下面给出一些我自己的理解:

- 在暴力法中， $i$ 的每一层循环都换了一个新长度初始为 $1$ 的尺子，尺子的左端点固定在 $i$ 处，右端点不断向右走。这样使其在 $i$ 的 $n$ 层循环中，每次换新尺子，每次尺子走了 $n-i$ 次，复杂度自然 $O(n^2)$。
- **因为**注意到换新尺子后与上面第 $i-1$ 层唯一的不同是左右端点内缩一格，但是中间的信息却要全部重新走一遍，这实际上让右段点查询每个点的信息至多 $n$ 次，重复询问信息导致复杂度必然提高。
- **所以**在尺取法中，我们不更换新尺子，而是将尺子最左右端的端点在必要时删去，形象的说就是尺子的一端点不动，另一端点向内缩了一格。也就是通过加上"删除已有点的贡献"这一操作替换掉复杂度高的"直接换新尺子"。~~这一思想在单调栈中也有运用。~~
