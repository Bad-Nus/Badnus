---
Tags:
  - 题解
---

# 题面
[P14507](../../../题面/洛谷题面/LGR-250-NOIP/P14507.md)

![[../../../题面/洛谷题面/LGR-250-NOIP/P14507|P14507]]

# 分析

$\operatorname{mex}$ 取决于从 $0$ 开始连续数字的数量，所以 $\operatorname{mex}$ 不会超过数字种数 $n$ 或所有数的 $\operatorname{mex}$，所以大于 $\operatorname{min}(n,mex_{tot})$ 的 $a_i$ 不用考虑。

预处理区间 $[0, n]$ 每个数的数量 $c_i$ ，那么从 $0$ 到 $i$ 的连续区间数量最大为 $f(i)=min(c_0,c_1\ldots c_i)$ ，即最长不增区间，也就是 $b_i$ 的前缀 $\operatorname{min}$

考虑到 $\operatorname{mex}$ 实际上是连续区间的长度 $l(如0,1,2,3\to l=mex=4)$ ，即 $\operatorname{mex}=l$ ，对 $k$ 个集合，有 

$$
\begin{split}
(\sum\limits_{j=1}^k \operatorname{mex_j})_{max}
&=\sum\limits_{j=1}^k \sum\limits_{l=1}^{mex_j}1\\
(交换取等)\quad&=\sum\limits_{l=1}^{n}\sum\limits_{(j:mex_j\ge l)}\\
(根据定义)\quad&=\sum\limits_{l=1}^{n}f(i)
\end{split}
$$

如此我们可以构造最大的 $\operatorname{mex}$ 值，大于该值无解，小于该值时对预处理的集合进行拆分与合并即可。

合并：剩余无法组成区间的数因为集合可重，放进 $t_i$ 个连续区间中无影响，集合合并时只要考虑 $\operatorname{mex}$ 取最大即可，集合 $A$ 与 $\operatorname{mex}$ 更大的集合 $B$ 合并，等价于集合 $A$ 不产生贡献。

拆分： $\operatorname{mex}$ 为 $x$ 的集合 $A$ 可以拆分成一个 $\operatorname{mex}$ 为 $x' (1\le x'\le x)$ 的集合 $B$ 和 $\operatorname{mex}$ 为 $0$ 的集合 $C$ ( $C$ 可以为空集) 。

受此启发，求得 $\operatorname{mex}_{\operatorname{max}}$ ，便可拆分合并得到其他 $\operatorname{mex}\le  \operatorname{mex}_{\operatorname{max}}$ 的方案。

考虑拆分对 $k$ 的影响，我们发现只要先拆 $\operatorname{mex}$ 小的，再拆大，将拆出来的集合放进 $\operatorname{mex}$ 更大的集合即可。若不存在 $\operatorname{mex}$ 更大集合才增加 $1$ 个集合来承受。
## 复杂度

**预处理**：排序 $O(n\log n)$
**每次查询**：二分：$O(\log n)$
**总复杂度**：$O(T(n+q)\log n)$

## 代码实现

```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
#define gc getchar
#define pc putchar
using namespace std;
const int N=1e6+1;
typedef long long ll;

ll read(){
    ll x=0,f=1;
    char ch=gc();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}
    while(ch>='0'&&ch<='9')x=(x*10)+(ch^48),ch=gc();
    return x*f;
}

void wrt(ll x){
    if(x<0)x=-x,pc('-');
    if(x>9)wrt(x/10);
    pc(x%10^48);
}

ll t,n,q,cnt[N],x,y,tmp,ntmp,idx,qwq,tot,mx;

struct nd{
    ll v,cnt,sum;
}ans[N];

ll find_high(ll x){
    ll l=1,r=idx,mid;
    while(l<r){
        mid=(l&r)+((l^r)>>1);
        if(ans[mid].sum>=x)r=mid;
        else l=mid+1;
    }
    return l;
}

bool cmp(nd a,nd b){
    return a.v>b.v;
}

int main(){
    for(t=read();t--;){
        n=read(),q=read();
        memset(cnt,0,sizeof(cnt));
        idx=mx=tot=0;
        
        rep(i,1,n){
            x=read(),y=read();
            if(x<=n)cnt[x]+=y;
        }
        
        tmp=cnt[0];
        rep(i,1,n){
            if(cnt[i]<tmp){
                ans[++idx]=nd{i,tmp-cnt[i],i*(tmp-cnt[i])};
                mx+=ans[idx].sum;
                tmp=cnt[i];
                tot+=ans[idx].cnt;
            }
        }
        
        sort(ans+1,ans+1+idx,cmp);
        rep(i,1,idx){
            ans[i].sum+=ans[i-1].sum;
            ans[i].cnt+=ans[i-1].cnt;
        }
        
        while(q--){
            x=read();
            if(x>mx)puts("-1");
            else if(!x&&!cnt[0])puts("1");
            else if(!x)puts("-1");
            else{
                tmp=find_high(x);
                x-=ans[tmp-1].sum;
                qwq=ans[tmp-1].cnt;
                qwq+=x/ans[tmp].v;
                qwq+=(x%ans[tmp].v!=0);
                if(qwq==0)qwq=1;
                wrt(qwq);pc('\n');
            }
        }
    }
    return 0;
}
```