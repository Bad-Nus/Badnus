# 题面
[SSLOJ-2025-8-11-T3.堆石子](../../../题面/SSLOJ题面/2025-8-11A/SSLOJ-2025-8-11-T3.堆石子.md)

![[../../../题面/SSLOJ题面/2025-8-11A/SSLOJ-2025-8-11-T3.堆石子|SSLOJ-2025-8-11-T3.堆石子]]
# 分析
> 首先，我们可以发现，取石子始终取 $m$ 个，对每堆石子数量及合并时可看作在模意义下。答案为 $n$ 堆中选择若干堆的数量取模最大，即希望最大化:

$$ans=(\sum_{1\le j\le n}S_j)\% m$$
**子任务:**
> 对于30%的数据：直接 $O(2^n)$ 枚举选择的石子堆即可。

> 对于另外20%的数据：记 $f(i, j)$ 表示前 $i$ 个数字能否选出组合来表示 $j$ ，就变成了一个背包问题或搜索。

**正解:**
> $n\le 35$ 直接搜爆炸，折半搜索刚好，但折半搜索后对两半各取合并复杂度仍是 $O((2^{\frac n 2})^2)=O(2^n)$ 的，注意到答案要求最大，具有一定的单调性，考虑利用这个性质进行优化。
> 
> 我们对两堆进行合并时，设他们的数量分别为 $x$ , $y$ ($x\lt y\lt m$)
> 
> 那么在模意义下有:

$$
\begin{cases}
x\lt y\lt(x+y) &if\quad x+y\lt m\\
(x+y)\lt x\lt y&if\quad x+y\ge m
\end{cases}
$$
> 那么对答案的贡献为 $$ans\leftarrow \begin{cases}
x+y&if\quad x+y\lt m\\
max(x,y)&if\quad x+y\ge m
\end{cases}$$

> 那么对一堆数量 $x$ 的石堆想通过合并的方式来最大化贡献，只要在其他石堆中寻找数量小于 $m-x$ 的数量最多石堆并合并，该步骤在有序情况下可以用二分解决。

> 但我们扔不清楚合并的顺序，该贪心无法直接得出答案，只在考虑仅合并一次时最优。刚好用做折半合并部分的优化。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+1;
int n,m,ans,a[N],b[N],len;
void getmax(int x){ans=max(ans,x);}
int find(int x){
	auto pos=lower_bound(b+1,b+1+len,m-x)-b;
	return max(x,b[pos-1]+x);
}
void dfs(int pos,int num){
	if( !pos)return getmax(b[++len]=num);
	dfs(pos-1,num),dfs(pos-1,(num+a[pos])%m);
}
void bfs(int pos,int num){
	if(pos>n)return getmax(find(num));
	bfs(pos+1,num),bfs(pos+1,(num+a[pos])%m);
}
signed main(){
    scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)scanf("%d",a+i);
	dfs(n/2+0,0),sort(b+1,b+1+len);
	bfs(n/2+1,0);
    return cout<<ans,0;
}
```