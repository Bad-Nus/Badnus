---
Tags:
  - 题解
---
# 题面
[SSLOJ-2025-8-11-T3.堆石子](../../../题面/SSLOJ题面/2025-8-11A/SSLOJ-2025-8-11-T3.堆石子.md)

![[../../../题面/SSLOJ题面/2025-8-11A/SSLOJ-2025-8-11-T3.堆石子|SSLOJ-2025-8-11-T3.堆石子]]
# 分析
> 首先，我们可以发现，取石子始终取 $m$ 个，对每堆石子数量及合并时可看作在模意义下。答案为 $n$ 堆中选择若干堆的数量取模最大，即希望最大化:

$$ans=\mathrel \max(\sum S_j)\% m$$
**子任务:**
> 对于30%的数据：直接 $O(2^n)$ 枚举选择的石子堆即可。

> 对于另外20%的数据：记 $f(i, j)$ 表示前 $i$ 个数字能否选出组合来表示 $j$ ，就变成了一个背包问题或搜索。

**正解:**
> 在看到答案有经典的 $O(2^n)$ 且操作符合结合律的暴力，更有 $n\le 48$ 时，就应该及时想到折半搜索并思考如何合并答案。
> 
> 答案里 $\sum$ 是折半搜索常客，但带模取 $max$ 操作的暴力维护合并答案是 $O((n^{\frac n 2})^2)=O(2^n)$ 的，考虑取模和取 $max$ 分别有哪些性质并进行维护。
> 
> 我们对两堆进行合并时，设他们的数量分别为 $x$ , $y$ ($x\lt y\lt m$)
> 
> 那么在模意义下有:

$$
\begin{cases}
x\lt y\lt(x+y) &if\quad x+y\lt m\\
(x+y)\lt x\lt y&if\quad x+y\ge m
\end{cases}
$$
> 那么对答案的贡献为 

$$ans\leftarrow \begin{cases}
x+y&if\quad x+y\lt m\\
max(x,y)&if\quad x+y\ge m
\end{cases}$$

> 那么对一堆数量 $x$ 的石堆想通过合并的方式来最大化贡献，只要在其他石堆中寻找数量小于 $m-x$ 的数量最多石堆并合并，该步骤在有序情况下可以用二分解决。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+1;
int n,m,ans,a[N],b[N],len;
void getmax(int x){ans=max(ans,x);}
int find(int x){
	auto pos=lower_bound(b+1,b+1+len,m-x)-b;
	return max(x,b[pos-1]+x);
}
void dfs(int pos,int num){
	if( !pos)return getmax(b[++len]=num);
	dfs(pos-1,num),dfs(pos-1,(num+a[pos])%m);
}
void bfs(int pos,int num){
	if(pos>n)return getmax(find(num));
	bfs(pos+1,num),bfs(pos+1,(num+a[pos])%m);
}
signed main(){
    scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)scanf("%d",a+i);
	dfs(n/2+0,0),sort(b+1,b+1+len);
	bfs(n/2+1,0);
    return cout<<ans,0;
}
```