---
Tags:
  - 题解
---
# 题面
[SSLOJ-2025-8-11-T4.不稳定的导弹系统](../../../题面/SSLOJ题面/2025-8-11A/SSLOJ-2025-8-11-T4.不稳定的导弹系统.md)

![[../../../题面/SSLOJ题面/2025-8-11A/SSLOJ-2025-8-11-T4.不稳定的导弹系统|SSLOJ-2025-8-11-T4.不稳定的导弹系统]]
# 分析
本题的关键在于如何处理导弹飞行路线的交叉问题。

首先，东西方向的导弹发射器和南北方向的导弹发射器的发射路径之间才可能产生交叉，因为题目中的"注"中已经说明了这一点。但还是毫无头绪，所以要试着将它建模，转化成我们能找到思路的模型。我们发现，导弹发射路线的交叉其实显示了一条导弹发射器之间的路线，不妨设路线是从南北方向的导弹发射到东西方向的导弹发射器单向的，于是我们就能够用最小割来求答案。

其次考虑如何设定每条路线的"容量"。不妨设一条从 $u$ 到 $v$ 的割边代表我们攻击了 $u$ 这个区域。先找出导弹发射器在它攻击路径上的最大频率数量，记为 $max$，那么对于一个频率数为 $w$ 的区域，它所对应的边的容量就应该是 $max - w$ ，就是如果选择了这个区域，那么产生的损失就是 $max - w$ 。

但是我们却发现，在一些情况下存在从源点到汇点的路径，但是却没有实际的方案与之对应，原因是我们上述的"路线"只涉及了一行一列。解决的方法并不复杂，只需将一个点拆成横点和竖点，横点向竖点连一条容量无限大的边，竖点不向横点连边即可解决。
# 代码
```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
#define per(u,x,y) for(int u=x;u>=y;--u)
#define int long long
using namespace std;
int read(){
	int x=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')((ch=='-')&&(w=-1,0)),ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<3)+x+x+(ch^48),ch=getchar();
	return x*w;
}
void wrt(int x){
	if(x<0)x=-x,putchar('-');
	if(x>9)wrt(x/10);
	putchar(x%10^48);
}
const int N=55,M=2e5+10,inf=0x3f3f3f3f;
int n,m,tot,mx,hh,tt,s,t,d[M],cur[M],que[M],e[N][N],ans,mp,k;
int pre[M],nxt[M],h[M],w[M],idx=1;
void add(int x,int y,int z){
	h[++idx]=y,nxt[idx]=pre[x],w[pre[x]=idx]=z;
	h[++idx]=x,nxt[idx]=pre[y],w[pre[y]=idx]=0;
}
int id(int x,int y,int z) {return (x-1)*m+y+(z?n*m:0);}
bool bfs(){
	memset(d,0,sizeof d);
	queue<int>q;
	d[s]=1;
	q.push(s);
	while(q.size()){
		int u=q.front();q.pop();
		for(int i=pre[u];i;i=nxt[i]){
			if(w[i]&&!d[h[i]]){
				d[h[i]]=d[u]+1;
				if(h[i]==t)return 1;
				q.push(h[i]);
			}
		}
	}
	return 0;
}
int dfs(int u,int lim){
	if(u==t||!lim)return lim;
	int flow=0,f;
	for(int &i=cur[u];i&&flow<lim;i=nxt[i]){
		if(w[i]&&d[h[i]]==d[u]+1){
			f=dfs(h[i],min(lim,w[i]));
			if(!t)d[h[i]]=-1;
			w[i]-=f,w[i^1]+=f,lim-=f,flow+=f;
			if(!lim)break;
		}
	}
	return flow;
} 
int dinic(){
	int res=0;
	while(bfs())memcpy(cur,pre,sizeof cur),res+=dfs(s,inf);
	return res;
}
void build(int x,int y,int op){
	e[x][y]=mp=0,k=-1;
	if(op==-1){
		add(s,id(x,y,0),inf);
		per(i,x-1,1)if(e[i][y]>mp)mp=e[i][y],k=i;
		if(!~k)return;
		per(i,x-1,k)add(id(i+1,y,0),id(i,y,0),mp-e[i+1][y]);
	}
	else if(op==-2){
		add(s,id(x,y,0),inf);
		rep(i,x+1,n)if(e[i][y]>mp)mp=e[i][y],k=i;
		if(!~k)return;
		rep(i,x+1,k)add(id(i-1,y,0),id(i,y,0),mp-e[i-1][y]);
	}
	else if(op==-3){
		add(id(x,y,1),t,inf);
		per(i,y-1,1)if(e[x][i]>mp)mp=e[x][i],k=i;
		if(!~k)return;
		per(i,y-1,k)add(id(x,i,1),id(x,i+1,1),mp-e[x][i+1]);
	}
	else {
		add(id(x,y,1),t,inf);
		rep(i,y+1,m)if(e[x][i]>mp)mp=e[x][i],k=i;
		if(!~k)return;
		rep(i,y+1,k)add(id(x,i,1),id(x,i-1,1),mp-e[x][i-1]);
	}
	ans+=mp;
}
signed main(){
	n=read(),m=read(),s=n*m*2+1,t=n*m*2+2;;
	rep(i,1,n)rep(j,1,m)e[i][j]=read();
	rep(i,1,n)rep(j,1,m)add(id(i,j,0),id(i,j,1),inf),(e[i][j]<0)&&(build(i,j,e[i][j]),0),++tot;
    return cout<<(tot?ans+mp-dinic():0),0;
}
```