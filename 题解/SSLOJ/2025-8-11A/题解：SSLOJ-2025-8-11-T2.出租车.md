---
Tags:
  - 题解
---
# 题面
[SSLOJ-2025-8-11-T2.出租车](../../../题面/SSLOJ题面/2025-8-11A/SSLOJ-2025-8-11-T2.出租车.md)

![[../../../题面/SSLOJ题面/2025-8-11A/SSLOJ-2025-8-11-T2.出租车|SSLOJ-2025-8-11-T2.出租车]]
# 分析
**对于 30% 的数据** 

> 由于需要按照编号顺序上车，我们可以按照编号进行搜索，我们可以记录（第几个人，当前停靠点，出租车里的 $4$ 个人的编号），由于需要按照编号上车，所以要么直接去接当前的人，要么先送车里的人到目的地，再去接当前的人。

**k=2**

> 模拟即可，只能每次 $1$ 到 $2$ , $2$ 到 $1$ 。

**对于100%的数据**

> 我们发现我们并不需要记录编号，我们并不关心出租车里是谁，我们只关心车里的人要到哪里去，所以只需要记录要到达的停靠点编号，由于 $4$ 人满后必须要送一个人到目的地，所以我们只需要记录 $3$ 个人的目的地即可，这样会出现较多的重复状态，可以用记忆化搜索减少重复状态的搜索。时间复杂度 $O(nk^4)$
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=1e9,N=2010,M=11;
int n,k,u[N],v[N],f[N][M][M][M][M];
inline int dist(int a,int b){return abs(a-b);}
int dfs(int i,int cur,int a,int b,int c){
    if(~f[i][cur][a][b][c])return f[i][cur][a][b][c];
    int res=inf;
    if(a)res=min(res,dfs(i,a,0,b,c)+dist(cur,a)+1);
    if(b)res=min(res,dfs(i,b,a,0,c)+dist(cur,b)+1);
    if(c)res=min(res,dfs(i,c,a,b,0)+dist(cur,c)+1);
    if(i>n){
        if(a==0&&b==0&&c==0)return 0;
        return f[i][cur][a][b][c]=res;
    }
    if(a&&b&&c){
        res=min(res,dfs(i+1,v[i],a,b,c)+dist(cur,u[i])+dist(u[i],v[i])+2);
        res=min(res,dfs(i+1,a,v[i],b,c)+dist(cur,u[i])+dist(u[i],a)+2);
        res=min(res,dfs(i+1,b,a,v[i],c)+dist(cur,u[i])+dist(u[i],b)+2);
        res=min(res,dfs(i+1,c,a,b,v[i])+dist(cur,u[i])+dist(u[i],c)+2);
    }else{
        if(!a)res=min(res,dfs(i+1,u[i],v[i],b,c)+dist(cur,u[i])+1);
        if(!b)res=min(res,dfs(i+1,u[i],a,v[i],c)+dist(cur,u[i])+1);
        if(!c)res=min(res,dfs(i+1,u[i],a,b,v[i])+dist(cur,u[i])+1);
    }
    return f[i][cur][a][b][c]=res;
}

signed main(){
    memset(f,-1,sizeof f);
    cin>>n>>k;
    for(int i=1;i<=n;++i)cin>>u[i]>>v[i];
    cout<<dfs(1,1,0,0,0);
    return 0;
}
```