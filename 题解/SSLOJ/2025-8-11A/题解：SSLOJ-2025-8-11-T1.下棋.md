# 题面
[SSLOJ-2025-8-11-T1.下棋](../../../题面/SSLOJ题面/2025-8-11A/SSLOJ-2025-8-11-T1.下棋)

![[../../../题面/SSLOJ题面/2025-8-11A/SSLOJ-2025-8-11-T1.下棋]]
# 分析
记忆化搜索：我们记 $f(a, b, x, y)$ 为当前已经放了 $a$ 个白色棋子， $b$ 个黑色棋子，后缀中白色棋子最多比黑色棋子多 $x$ 个，后缀中黑色棋子最多比白色多 $y$ 个。那么每一步转移就是枚举放黑色还是白色。

**白色：** $f(a+1, b, c+1, \max(0, d-1))$ ，当 $a < n$ 且 $c < k$ 时

**黑色：** $f(a, b+1, \max(0, c-1), d+1)$ ，当 $b < m$ 且 $d < k$ 时

时间复杂度 $O(nmk^2)$
# 代码
```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
using namespace std;
const int mod=1e9+7,N=210,K=30;
int n,m,k,mx,mn,f[N][N][K][K];
int dfs(int a,int b,int c,int d){
	if(a==n&&b==m)return 1;
	if(~f[a][b][c][d])return f[a][b][c][d];
	int tmp=0;
	if(a<n&&c<k)tmp=(tmp+dfs(a+1,b,c+1,max(0,d-1)))%mod;
	if(b<m&&d<k)tmp=(tmp+dfs(a,b+1,max(0,c-1),d+1))%mod;
	return f[a][b][c][d]=tmp;
}
int main(){
	cin>>n>>m>>k;
	rep(i,0,n)rep(j,0,m)rep(x,0,k)rep(y,0,k)f[i][j][x][y]=-1;
	return cout<<dfs(0,0,0,0),0;
}
```