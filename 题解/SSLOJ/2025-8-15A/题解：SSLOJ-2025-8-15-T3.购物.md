---
Tags:
  - 题解
---
# 题面
[SSLOJ-2025-8-15-T3.购物](../../../题面/SSLOJ题面/2025-8-15A/SSLOJ-2025-8-15-T3.购物.md)

![[../../../题面/SSLOJ题面/2025-8-15A/SSLOJ-2025-8-15-T3.购物|SSLOJ-2025-8-15-T3.购物]]
# 分析
$n \times k$ 过大，无法 $dp$ ，考虑贪心。

首先， $K$ 张优惠券或是全部用上，或是购买的物品不足 $K$ 个，且所有的物品都用上了优惠券。不妨先购买 $Qi$ 最小的 $K$ 件物品，然后将这些商品的 $（Pi - Qi）$ 记录在小根堆中，视为能够花费  $Pi - Qi$ 重新获得一张优惠券，以此为根据反悔贪心即可。
# 代码
```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
using namespace std;
const int N=1e6+1;
int n,k,m,p[N],c[N],idx;
bool vis[N];
struct nd{int val,ord;bool operator<(const nd&a)const{return val>a.val;}}tmp;
priority_queue<nd>q1,q2;
priority_queue<int,vector<int>,greater<int> >q;
signed main(){
	cin>>n>>k>>m;
	rep(i,1,n)cin>>p[i]>>c[i],q1.push({p[i],i}),q2.push({c[i],i});
	rep(i,1,k)q.push(0);
	while(idx++<n){
		while(vis[q1.top().ord])q1.pop();
		while(vis[q2.top().ord])q2.pop();
		if(q.top()+q2.top().val<q1.top().val){
			tmp=q2.top();
			m-=tmp.val+q.top();
			if(m<0)break;
			q.pop(),q2.pop();
			q.push(p[tmp.ord]-c[tmp.ord]);
			vis[tmp.ord]=1;
		}else{
			tmp=q1.top();
			m-=tmp.val;
			if(m<0)break;
			q1.pop();
			vis[tmp.ord]=1;
		}
		++idx;
	}
    return cout<<idx,0;
}

```