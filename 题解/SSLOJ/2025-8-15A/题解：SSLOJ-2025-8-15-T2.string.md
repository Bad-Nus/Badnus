# 题面
[SSLOJ-2025-8-15-T2.string](../../../题面/SSLOJ题面/2025-8-15A/SSLOJ-2025-8-15-T2.string.md)

![[../../../题面/SSLOJ题面/2025-8-15A/SSLOJ-2025-8-15-T2.string|SSLOJ-2025-8-15-T2.string]]
# 分析
子任务直接排序就好。

正解是维护排序操作，可以开 $26$ 个线段树做桶排。
# 代码
先放 ai 代码，后补
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m;
string s;
struct Seg {
    vector<array<int,26>> cnt;
    vector<int> lazy; // -1 表示无懒标记，否则 0..25 表示全部该字母
    Seg(int sz=0) { init(sz); }
    void init(int sz) {
        cnt.assign(4*sz+5, array<int,26>{});
        lazy.assign(4*sz+5, -1);
    }
    void build(int p, int l, int r) {
        if (l==r) {
            for (int i=0;i<26;i++) cnt[p][i]=0;
            cnt[p][s[l-1]-'a']=1;
            return;
        }
        int mid=(l+r)>>1;
        build(p<<1,l,mid);
        build(p<<1|1,mid+1,r);
        push_up(p);
    }
    void push_up(int p) {
        for (int i=0;i<26;i++) cnt[p][i]=cnt[p<<1][i]+cnt[p<<1|1][i];
    }
    void apply_set(int p, int l, int r, int c) {
        for (int i=0;i<26;i++) cnt[p][i]=0;
        cnt[p][c]=r-l+1;
        lazy[p]=c;
    }
    void push_down(int p, int l, int r) {
        if (lazy[p]==-1) return;
        int mid=(l+r)>>1;
        apply_set(p<<1, l, mid, lazy[p]);
        apply_set(p<<1|1, mid+1, r, lazy[p]);
        lazy[p]=-1;
    }
    array<int,26> query(int p, int l, int r, int ql, int qr) {
        array<int,26> res; res.fill(0);
        if (ql<=l && r<=qr) return cnt[p];
        push_down(p,l,r);
        int mid=(l+r)>>1;
        if (ql<=mid) {
            auto t = query(p<<1,l,mid,ql,qr);
            for (int i=0;i<26;i++) res[i]+=t[i];
        }
        if (qr>mid) {
            auto t = query(p<<1|1,mid+1,r,ql,qr);
            for (int i=0;i<26;i++) res[i]+=t[i];
        }
        return res;
    }
    void update_set(int p, int l, int r, int ql, int qr, int c) {
        if (ql>r || qr<l) return;
        if (ql<=l && r<=qr) { apply_set(p,l,r,c); return; }
        push_down(p,l,r);
        int mid=(l+r)>>1;
        if (ql<=mid) update_set(p<<1,l,mid,ql,qr,c);
        if (qr>mid) update_set(p<<1|1,mid+1,r,ql,qr,c);
        push_up(p);
    }
    void collect(int p, int l, int r, string &out) {
        if (l==r) {
            for (int i=0;i<26;i++) if (cnt[p][i]) { out[l-1]=char('a'+i); break; }
            return;
        }
        if (lazy[p]!=-1) {
            for (int i=l;i<=r;i++) out[i-1]=char('a'+lazy[p]);
            return;
        }
        int mid=(l+r)>>1;
        collect(p<<1,l,mid,out);
        collect(p<<1|1,mid+1,r,out);
    }
} seg;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    if (!(cin>>n>>m)) return 0;
    cin>>s;
    seg.init(n);
    seg.build(1,1,n);
    for (int qi=0; qi<m; ++qi) {
        int l,r,x;
        cin>>l>>r>>x;
        auto cnt = seg.query(1,1,n,l,r);
        int cur = l;
        if (x==1) {
            for (int c=0;c<26;c++){
                if (cnt[c]==0) continue;
                seg.update_set(1,1,n,cur,cur+cnt[c]-1,c);
                cur += cnt[c];
            }
        } else {
            for (int c=25;c>=0;c--){
                if (cnt[c]==0) continue;
                seg.update_set(1,1,n,cur,cur+cnt[c]-1,c);
                cur += cnt[c];
            }
        }
    }
    string out(n,'?');
    seg.collect(1,1,n,out);
    cout<<out<<"\n";
    return 0;
}
```