---
Tags:
  - 题解
---
# 题面
[SSLOJ-2025-8-15-T1.餐馆](../../../题面/SSLOJ题面/2025-8-15A/SSLOJ-2025-8-15-T1.餐馆.md)

![[../../../题面/SSLOJ题面/2025-8-15A/SSLOJ-2025-8-15-T1.餐馆|SSLOJ-2025-8-15-T1.餐馆]]
# 分析
考虑树形 $\text{dp}$ ，但需要考虑子树回到父节点的花费的时间。

原来不考虑回父节点时，枚举子树，枚举当前子树准备花费多少时间，再枚举一个之前其他子树花费的时间做泛化背包，复杂度 $O(n^3)$

我们发现，从在一个树节点 $i$ 上，对 $i$ 任意子树 $x$ 计算贡献时，有两个选择：
1. 回到父节点并与其他子树合并贡献
2. 不回父节点

如果选择 1 ，那么必然对其他子树计算贡献时，必须计算需要回到父节点的最大贡献，最终停在 $x$ 树上。

但这样不仅要多维护一维信息表示是否回溯，还要去枚举哪一个子树停下，加上原来的枚举复杂度 $O(n^4)$ 不可接受，考虑原来的枚举不好优化，对多出的复杂度优化。

我们可以发现，枚举停下的子树会重复计算其他子树贡献，在实际编码时就能感受到。我们实际上只要对每个节点枚举时间求出一定时间下，回到父节点和不回父节点分别的最大价值。若是不回父节点的情况下就要求后面的子树均回到父节点即可。

那么，我们设：

$f_{i,j,0}$ 为在以 $i$ 为根的子树中，花费 $j$ 单位时间，最终回到 $i$ 的最大价值。

$f_{i,j,1}$ 为在以 $i$ 为根的子树中，花费 $j$ 单位时间，最终不回到 $i$ 的最大价值。

那么转移便很好理解和建模：
1. (继续走)之前子树回根，当前子树 $s$ 花费 $k$ 回根：
$$f_{i,j,0}=\stackrel{j-1}{\underset{k=0}{max}}(f_{i,j-k,0}+f_{s,k,0})$$
2. (现在停下)之前子树回根，当前子树 $s$ 花费 $k$ 不回根：
$$f_{i,j,1}=\stackrel{j-2}{\underset{k=0}{max}}(f_{i,j-k,0}+f_{s,k,0})$$
3. (重返过去停下)之前子树不回根，当前子树 $s$ 花费 $k$ (必须)回根：
$$f_{i,j,1}=\stackrel{j-2}{\underset{k=0}{max}}(f_{i,j-k,1}+f_{s,k,0})$$
# 代码
```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
#define per(u,x,y) for(int u=x;u>=y;--u)
using namespace std;
const int N=510,INF=-1e9;
int n,m,a[N],dp[N][N][2],sz[N],x,y,ans,v,lu,lv;
vector<int>e[N];
void dfs(int u, int fa){
	sz[u]=1;
	dp[u][0][0]=0;
    dp[u][1][0]=a[u-1];
	for(auto v:e[u])if(v!=fa)dfs(v,u),sz[u]+=sz[v];
    lu=min(m,3*sz[u]);
    for(auto v:e[u]){
        if(v==fa)continue;
        lv=min(m,3*sz[v]);
        per(j,lu,0){
        	rep(k,0,min(lv,j-1)){
                dp[u][j][0]=max(dp[u][j][0],dp[u][j-k-2][0]+dp[v][k][0]);
                dp[u][j][1]=max(dp[u][j][1],dp[u][j-k-2][1]+dp[v][k][0]);
                dp[u][j][1]=max(dp[u][j][1],dp[u][j-k-1][0]+max(dp[v][k][0],dp[v][k][1]));
            }
        }
    }
}

int main() {
    cin>>n>>m;
    rep(i,0,n-1)cin>>a[i];
    rep(i,0,n-2)cin>>x>>y,e[x].push_back(y),e[y].push_back(x);
    memset(dp,0xc0,sizeof(dp));
    dfs(1,-1);
    rep(i,0,m)ans=max(ans,max(dp[1][i][0],dp[1][i][1]));
    return cout<<ans,0;
}
```