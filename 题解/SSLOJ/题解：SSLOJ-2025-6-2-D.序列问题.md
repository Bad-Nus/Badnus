---
Tags:
  - 题解
---
# 题面
[SSLOJ-2025-6-2-D.序列问题](../../题面/SSLOJ题面/SSLOJ-2025-6-2-D.序列问题.md)

![[../../题面/SSLOJ题面/SSLOJ-2025-6-2-D.序列问题|SSLOJ-2025-6-2-D.序列问题]]
# 分析
> 题面简明。
> 
> 我们设 $f_i$ 为处理完 $1\sim(i-1)$ 位的答案，在第 $i$ 位的最大答案。
> 
> 设最终的序列为 $a$ ，想令 $a_j=j$ 当仅 $x_i=a_j=j\leq i$ ，因为新位置 $j$ 不可能大于原位置 $i$ .
> 
> 那么对所有 $j<i$ ，满足 $x_i\le i,x_i-x_j\le i-j$ ，那么 $dp_i=max(dp_j+1)$
> 
> 我们令 $b_i=i-x_i$ ，上条件转化为对所有 $j<i$ ，满足 $b_i\ge b_j\ge 0$
> 
> 即转化为对 $x$ 排序，对 $b$ 做最长不降子序列。
# 代码
```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
using namespace std;
const int N=5000001;
int a[N],b[N],n,top,st[N];
void solve(int h,int t){
    int l=h,r=t,m=a[(h+t)>>1],n=b[(h+t)>>1];
    do
    {
        while(a[l]<m || (a[l]==m && b[l]>n))l++;
        while(a[r]>m || (a[r]==m && b[r]<n))r--;
        if(l<=r)
        {
            swap(a[l],a[r]);
            swap(b[l++],b[r--]);
        }
    }while(l<=r);
    if(h<r)solve(h,r);
	if(l<t)solve(l,t);
}
void pushin(int num){
    int h=0,t=top,w=0;
    while(h<=t)
    {
        int m=(h+t)/2;
        if(st[m]>num)t=m-1;
		else h=m+1,w=m;
    }
    st[++w]=num;
    if(top<w)top=w;
} 
int main()
{
    cin>>n;
    rep(i,1,n)cin>>a[i],b[i]=i-a[i];
    solve(1,n);
    rep(i,1,n)if(b[i]>=0)pushin(b[i]);
    return cout<<top,0;
}
```