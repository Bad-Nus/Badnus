# 题面
[SSLOJ-2025-8-6-T1.和谐关系](../../../题面/SSLOJ题面/2025-8-6A/SSLOJ-2025-8-6-T1.和谐关系.md)

![[../../../题面/SSLOJ题面/2025-8-6A/SSLOJ-2025-8-6-T1.和谐关系]]
# 分析
> 由于题目有关出题人的执念，于是我们把执念简化，理头表示建边，理头时间表示边权。又初始只有可以为自己理头的人自理，才能给别人理，称这些人为 VIP 点。
> 
> 初始只能由 VIP 点出发建边，再由别的点建边，不妨假定有一超级原点 $R$ ，向所有 VIP 点建边，边权为 VIP 点自理的时间。那么题目要求的最短时间便是以 $R$ 为根的最小生成树
> 
> 代码实现方面，由于 $m\approx O(n^2)$，采用 $O(n^2)$ 的Prim 而非 $O(m\log m)$ 的 Kruskal
# 代码
```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
using namespace std;
const int N=2e3;
int n,m,dp[N],a[N][N],ans,x,y,z,to;
bool vis[N];
int main(){
//	freopen("tickets.in","r",stdin);
//	freopen("tickets.out","w",stdout);
	cin>>n>>m;
	memset(dp,0x3f,sizeof dp),memset(a,0x3f,sizeof a);
	rep(i,1,m){
		cin>>x>>y>>z;
		if(x==y)x=0;
		a[y][x]=a[x][y]=min(a[x][y],z);
	}
	dp[0]=0;
	rep(i,0,n){
		to=n+1;
		rep(j,0,n)if(!vis[j]&&(to==n+1||dp[to]>dp[j]))to=j;
		ans+=dp[to];
		rep(j,0,n)dp[j]=min(dp[j],a[to][j]);
		vis[to]=1;
	}
	return cout<<ans,0;
}
```