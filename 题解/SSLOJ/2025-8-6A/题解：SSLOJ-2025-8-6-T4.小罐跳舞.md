---
Tags:
  - 题解
---
# 题面
[SSLOJ-2025-8-6-T4.小罐跳舞](../../../题面/SSLOJ题面/2025-8-6A/SSLOJ-2025-8-6-T4.小罐跳舞.md)

![[../../../题面/SSLOJ题面/2025-8-6A/SSLOJ-2025-8-6-T4.小罐跳舞|SSLOJ-2025-8-6-T4.小罐跳舞]]
# 分析
> 由题面提示可以想到让 $A,B$ 矩阵乘一个矩阵，再让 $C$ 矩阵乘矩阵，然后检验是否相同。从降低复杂度的目标出发容易想到乘一个随机一维矩阵来验证，因为二维矩阵乘一维矩阵的复杂度为 $O(n^2)$ 。
> 
> 设 $R$ 为一个 $1\times N$ 的一维矩阵，那么验证 $A\times (B\times R)=C\times R$ 即可。
> 
> (矩阵乘法不符合交换律，不能先用 $A$ 先乘)
# 代码
```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
using namespace std;
typedef long long ll;
const int N=1001;
ll n,a[N][N],b[N][N],c[N][N],d[N],e[N],r[N],ans;
void mul(const ll x[N][N],const ll y[N],ll k[N]){
	rep(i,1,n){
		k[i]=0;
		rep(j,1,n)k[i]=(k[i]+x[i][j]*y[j]);
	}
}
int main(){
//	freopen("transform.in", "r", stdin);
//  freopen("transform.out", "w", stdout);
    mt19937 gen(time(0));//随机数 
    while(cin>>n){
		rep(i,1,n)rep(j,1,n)cin>>a[i][j];
		rep(i,1,n)rep(j,1,n)cin>>b[i][j];
		rep(i,1,n)rep(j,1,n)cin>>c[i][j];
		ans=1;
		for(int tim=1;tim<=1;++tim){
			rep(i,1,n)r[i]=gen();                 //取随机R 
			
			mul(b,r,d);                           //计算 
			mul(a,d,e);
			mul(c,r,d);
			
			rep(i,1,n)if(d[i]!=e[i]){ans=0;break;}//检测 
		}
		if(ans)puts("Yes");
		else puts("No");
	}
	return 0;
}
```
