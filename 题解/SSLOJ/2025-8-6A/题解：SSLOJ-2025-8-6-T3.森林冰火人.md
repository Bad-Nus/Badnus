---
Tags:
  - 题解
---
# 题面
[SSLOJ-2025-8-6-T3.森林冰火人](../../../题面/SSLOJ题面/2025-8-6A/SSLOJ-2025-8-6-T3.森林冰火人.md)

![[../../../题面/SSLOJ题面/2025-8-6A/SSLOJ-2025-8-6-T3.森林冰火人]]
# 分析
> 总时间不超过 $4e4$ ，容易想到的 $dp$ 思路便是在一边时间不变的情况下，另一边尽可能少时间。然后枚举一边所用时间，更新在该时间下另一边的最短时间。
> 
> 设 $f_{i,j}$ 为在第 $i$ 任务，冰人用时为 $j$ 时，火人所用最短时间，有
 
$$\large f_{i,j}=min(f_{i-1,j-a[i]},(f_{i-1,j})+b[i])$$
# 代码
```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
using namespace std;
const int N=201;
typedef long long ll;
ll n,a[N],b[N],la,lb,len,dp[N][N*N],ans=INT_MAX;
int main(){
//	freopen("divide.in","r",stdin);
//	freopen("divide.out","w",stdout);
	cin>>n;
	rep(i,1,n)cin>>a[i]>>b[i],la+=a[i],lb+=b[i];
	len=max(la,lb);
	rep(i,1,n){
		for(ll j=len;j>=0;--j){
			dp[i][j]=dp[i-1][j]+b[i];
			if(j>=a[i])dp[i][j]=min(dp[i][j],dp[i-1][j-a[i]]); 
		}
	}
	for(ll j=len;j>=0;--j)ans=min(ans,max(j,dp[n][j]));
	cout<<ans;
	return 0;
}

```