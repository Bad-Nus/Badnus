---
Tags:
  - 题解
---
# 题面
[SSLOJ-2025-8-6-T2.小P别急](../../../题面/SSLOJ题面/2025-8-6A/SSLOJ-2025-8-6-T2.小P别急.md)

![[../../../题面/SSLOJ题面/2025-8-6A/SSLOJ-2025-8-6-T2.小P别急|SSLOJ-2025-8-6-T2.小P别急]]
# 分析
> 维护区间最大，区间修改单点修改，单点查询，单点删除。
> 
> 线段树，堆均可。这里用 $set$ 实现
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e6+100;
struct nd{
	ll val,tim;
	string nam;
	bool operator<(const nd&a)const{
		if(val==a.val)return tim<a.tim;
		return val<a.val;
		}
};
set<nd>q;
ll n,op,x,tim[N];
string k;
signed main(){
	freopen("mega.in","r",stdin);
	freopen("mega.out","w",stdout);
	auto it=q.begin();
	cin>>n;
	for(ll i=1;i<=n;++i){
		tim[i]+=tim[i-1],cin>>op;
		if(op==1)cin>>k>>x,q.insert({x+tim[i],i,k});
		else if(op==2)cin>>x,tim[i]+=x;
		else {
			if(q.size())it=--q.end();
			while(q.size()&&(it->val)<=(tim[i])){
				q.erase(it);
				if(q.size())it=--q.end();
			}
			if(q.empty())puts("Air 0");
			else it=--q.end(),cout<<(it->nam)<<' '<<(it->val)-(tim[i])<<('\n'),q.erase(it);
		}
	}
	return 0;
}
```