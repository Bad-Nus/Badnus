---
Tags:
  - 题解
---
# 题面
[SSLOJ-T493617 猴猴吃香蕉](../../题面/SSLOJ题面/SSLOJ-T493617%20猴猴吃香蕉.md)

![[../../题面/SSLOJ题面/SSLOJ-T493617 猴猴吃香蕉|SSLOJ-T493617 猴猴吃香蕉]]
# 分析
> 给定 $n$ 元序列 $a$ 和正整数 $k$,求有多少种不同的 $a$ 的子序列的序列积为 $k$,显然选中所有元素为 $k$ 的因子.

> 我们设 $dp_x$ 表示 $a$ 的子序列积等于 $x$ 的子序列个数.
> $cnt_x$ 为 $a$ 中元素 $x$ 的个数
> 
> 显然有 
>  $$dp_k=\sum_{p|k} {({cnt}_{\frac k p} \times {dp_p})}$$ 
> 初始 $dp$ 数组为 $0$,设 $k$ 的因子集 $v$,为方便转移我们初始时令 $dp_1=1$
> 
> 每次出现 $k$ 的因子,遍历 $k$ 的因子集 $pt$, $dp_{(k\times pt_i)}+=dp_{(pt_i)}$
> 
> (最后令 $dp_1-=1$,防止 $k=1$ 时出错）
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;    
#define to(x,y) for(int x=1;x<=y;++x)    
#define fr(x,y) for(int x=0;x<y;++x)    
#define fast ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    
inline void w(int x) {if (x < 0) {x = -x;putchar('-');}if (x > 9) w(x / 10);putchar(x % 10 + '0');}    
inline int read(){int x=0,f=1;char ch=getchar();while(ch<48||ch>57){if(ch=='-')f=-1;ch=getchar();}while(ch>=48&&ch<=57)x=x*10+ch-48,ch=getchar();return x*f;}    
inline string sread(){string ans;char ch=getchar(); while(ch==' '||ch=='\n'||ch=='\t')ch=getchar(); while(ch!=' '&&ch!='\n'&&ch!='\t')ans+=ch,ch=getchar();return ans;}    
bool isp(int num){if(num==1)return 0;if(num==2||num==3)return 1;if(num%6!=1&&num%6!=5)return 0;int tmp=sqrt(num);for(int i=5;i<=tmp;i+=6)if(num%i==0||num%(i+2)==0)return 0;return 1;}  
typedef long long ll;  
const int N=2001,Mod=1e9+7;  
int x,n,k,idx,pt[N];  
map<int,ll> dp;  
int main(){  
	  for(int t=read();t--;){  
		n=read(),k=read();  
		
		dp.clear();idx=0;  
		
		for(int j=1;j*j<=k;j++){
			if(k%j==0){
				pt[++idx]=j;
				if(j*j!=k)pt[++idx]=k/j;		
			}
		}
		sort(pt+1,pt+1+idx,greater<int>());
		
		to(i,n){
			x=read();if(x>k||k%x!=0)continue;
			to(j,idx){
				if(1ll*pt[j]*x<=k){
					dp[pt[j]*x]=(dp[pt[j]*x]+dp[pt[j]])%Mod;
				}
			}
			dp[x]++;
		}
		
		w(dp[k]),putchar('\n');
	}
	return 0;
}
```
