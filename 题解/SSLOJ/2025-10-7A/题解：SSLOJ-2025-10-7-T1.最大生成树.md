---
Tags:
  - 题解
---
# 题面
[SSLOJ-2025-10-7-T1.最大生成树](../../../题面/SSLOJ题面/2025-10-7A/SSLOJ-2025-10-7-T1.最大生成树.md)

![[../../../题面/SSLOJ题面/2025-10-7A/SSLOJ-2025-10-7-T1.最大生成树]]

# 分析
## 30%子任务
$n\le 10$ 纯暴力

## 50%子任务
$n\le 10^3$ 类比最小生成树的 $\text{kruskal}$ 我们从大到小加边即可 $O(n^2\log n)$

## 70% 子任务
由于边的数量为 $O(n^2)$ ， $n$ 为点数，而 $\text{kruskal}$ 需要对边排序，使用 $O(n^2)$ 的 $\text{prim}$

## 正解
我们不难证明，若每个点贪心选取最大边权的邻边，所形成的最大生成树必然最优。

> 证明：  
> 
> 将所有点权放到数轴上，每个点选最大边权，等价与每个点与 $a_{min}$ 或 $a_{max}$ 建边，取 $max(\vert a_i-a_{min}\vert,\vert a_i-a_{max}\vert)$ 即可。  
>   
> 最终选了 $n$ 个边，唯一成环的是 $a_{min}$ 与 $a_{max}$ 之间，将这条边去重后仍然满足每个点选取了最大边权边，且也刚好 $n-1$ 条边。没有更优的构造。 

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e5+1;
ll n,a[N],mn=INT_MAX,mx,ans;
int main(){
//	freopen("tree1.in","r",stdin);
//	freopen("tree1.out","w",stdout);
	cin>>n;
	for(ll i=1;i<=n;++i)cin>>a[i],mn=min(mn,a[i]),mx=max(mx,a[i]);
	for(ll i=1;i<=n;++i)ans+=max(abs(mx-a[i]),abs(mn-a[i]));
	return cout<<ans-mx+mn,0;
}
```
