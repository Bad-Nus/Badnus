---
Tags:
  - 题解
---
# 题面
[SSLOJ-2025-10-7-T2.红黑树](../../../题面/SSLOJ题面/2025-10-7A/SSLOJ-2025-10-7-T2.红黑树.md)

![[../../../题面/SSLOJ题面/2025-10-7A/SSLOJ-2025-10-7-T2.红黑树]]
# 分析
## 20%子任务
链，红黑子树数量很好维护。

## 50%子任务
暴力维护即可。

## 正解、
设树全集 $T=\{E,V\}$ ，其中 $V\neq\emptyset$ 为点集， $E$ 为边集。

考虑每个子树的变换只有 

$$红树\longrightarrow红黑树\longrightarrow黑树$$

所以只要考虑每颗子树在什么时段会成为红黑树，第一个子节点变黑时成为红黑树，最后一个子节点变黑时不再是红黑树。

记第 $i$ 个节点为根的子树 $T_i\in V$ ，该子树中最早变黑子节点的变黑时间为 $l_i$ ，最晚变黑子节点的变黑时间为 $r_i$ ，那么答案即为 $\sum\limits_{T_i\in V}[(r_i-1)-l_i+1]=\sum\limits_{T_i\in V}(r_i-l_i)$ ，深搜递归求 $l_i,r_i$ ，差分求和即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+1;
int n,a[N],p[N],x,ans[N];
int h[N],nxt[N],pre[N],idx;
void add(int x,int y){
	h[++idx]=y;
	nxt[idx]=pre[x];
	pre[x]=idx;
}
pair<int,int> dfs(int u){
	int mx=p[u],mn=p[u];
	for(int i=pre[u];i;i=nxt[i]){
		auto t=dfs(h[i]);
		mx=max(mx,t.second),mn=min(mn,t.first);
	}
	return ans[mn]++,ans[mx]--,make_pair(mn,mx);
}
int main(){
	freopen("tree2.in","r",stdin);
	freopen("tree2.out","w",stdout);
	cin>>n;
	for(int i=2;i<=n;++i)cin>>x,add(x,i);
	for(int i=1;i<=n;++i)cin>>x,p[x]=i;
	dfs(1);
	for(int i=1;i<=n;++i)ans[i]+=ans[i-1],cout<<ans[i]<<' ';
	return 0;
}
```