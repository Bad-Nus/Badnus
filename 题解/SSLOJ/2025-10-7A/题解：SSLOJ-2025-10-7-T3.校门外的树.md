---
Tags:
  - 题解
---
# 题面
[SSLOJ-2025-10-7-T3.校门外的树](../../../题面/SSLOJ题面/SSLOJ-2025-10-7-T3.校门外的树.md)

![[../../../题面/SSLOJ题面/2025-10-7A/SSLOJ-2025-10-7-T3.校门外的树]]
# 分析
线段树，不讨论子任务。
## 正解
对于一颗生长速度恒定的树，最终生长时间为 $t$ ，高度为 $h_t=h_0+t\times v_0$

生长速度变化 $1$ 次的，设在 $t_1$ 时刻变化为 $v_1$ ， $\Delta v=v_1-v_0$ ，则 $h_t=h_0+v_0\times t+v_1\times (t-t_1)=h_0+v_1\times t-\Delta v\times t_1$

拓展到题面，生长速度变化 $n$ 次的，设在 $t_i$ 时刻变化为 $v_i$ ，最终生长时间为 $t=t_{n+1}$ ，且 $\Delta v_i=v_i-v_{i-1}$ ，则有：

$$\begin{split}
h_t
&=h_0+\sum\limits_{0\le i\le n}(v_i\times t_{i+1})\\
&=h_0+v_n\times t_{n+1}-\sum\limits_{1\le i\le n}(\Delta v_i\times t_i)\\
&=h_0+t_{n+1}\times(v_0+\sum\limits_{1\le i\le n}\Delta v_i)-\sum\limits_{1\le i\le n}(\Delta v_i\times t_i)\\
&=h_0+t\times v_0+t\times\sum\Delta v_i-\sum(\Delta v_i\times t_i)\\
&=初始高度 + 当前时间×初始速度 + 当前时间×增量之和 - 增量时间积之和
\end{split}$$

其中前两项是定值，后两项用线段树维护 **增量之和** 和 **增量时间积之和** 即可。

```cpp
#include<bits/stdc++.h>
#define rep(i,l,r) for(int i=l;i<=r;++i)
#define mid ((pl+pr)>>1)
#define ls(p) (p<<1)
#define rs(p) (p<<1|1)
#define int unsigned long long
using namespace std;
const int N=2e6+10;
int n,m,op,x,y,z;
int addA[N],addB[N],h[N],v0[N];
int read(){
	int x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=(x*10)+(ch^48),ch=getchar();
	return x;
}
void wrt(int x){
	if(x>9)wrt(x/10);
	putchar(x%10^48);
}
struct Tree{
    int h,v0,A,B;
    Tree operator+(const Tree &a)const{return Tree{h+a.h,v0+a.v0,A+a.A,B+a.B};}
}tr[N];
void pushup(int p){tr[p]=tr[ls(p)]+tr[rs(p)];}
void addtag(int p,int l,int r,int da,int db){
    tr[p].A+=da*(r-l+1);
    tr[p].B+=db*(r-l+1);
    addA[p]+=da;
    addB[p]+=db;
}
void pushdown(int p,int pl,int pr){
    if(addA[p]||addB[p]){
        addtag(ls(p),pl,mid,addA[p],addB[p]);
        addtag(rs(p),mid+1,pr,addA[p],addB[p]);
        addA[p]=addB[p]=0;
    }
}

void build(int p=1,int pl=1,int pr=n){
    addA[p]=addB[p]=0;
    if(pl==pr){
        tr[p].h=read();
        tr[p].v0=read();
        tr[p].A=tr[p].B=0;
        return;
    }
    build(ls(p),pl,mid),build(rs(p),mid+1,pr);
    pushup(p);
}

void update(int l,int r,int da,int db,int p=1,int pl=1,int pr=n){
    if(l<=pl&&pr<=r){
        addtag(p,pl,pr,da,db);
        return;
    }
    pushdown(p,pl,pr);
    if(l<=mid)update(l,r,da,db,ls(p),pl,mid);
    if(r>mid)update(l,r,da,db,rs(p),mid+1,pr);
    pushup(p);
}

int query(int l,int r,int k,int p=1,int pl=1,int pr=n){
    if(l<=pl&&pr<=r)return tr[p].h + k*tr[p].v0 + k*tr[p].A - tr[p].B;
    pushdown(p,pl,pr);
    int res=0;
    if(l<=mid)res+=query(l,r,k,ls(p),pl,mid);
    if(r>mid)res+=query(l,r,k,rs(p),mid+1,pr);
    return res;
}

signed main(){
	freopen("tree3.in","r",stdin);
	freopen("tree3.out","w",stdout);
    n=read(),m=read(),build();
    rep(T,1,m){
        op=read(),x=read(),y=read();
        if(op==1)z=read(),update(x,y,z,z*T);
        else wrt(query(x,y,T)),putchar('\n');
    }
    return 0;
}
```