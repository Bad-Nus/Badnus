---
Tags:
  - 题解
---
# 题面
[SSLOJ-2025-8-18-T3.火车](../../../题面/SSLOJ题面/2025-8-18A/SSLOJ-2025-8-18-T3.火车.md)

![[../../../题面/SSLOJ题面/2025-8-18A/SSLOJ-2025-8-18-T3.火车]]
# 分析
子任务倍增，正解瓶颈在于标记已去。

正解采用妙妙 $trick$ ，我们发现很多树链和节点重复标记，且均是自底向上标记，一个标记会被走至多 $O(m)$ 次，均摊 $O(nm)$ 。

不难想到我们没标记过的正常走，走过的跳过去就好，用并查集记录被标记的点向上跳多少即可。
# 代码
```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
#define per(u,x,y) for(int u=x;u>=y;--u)
#define int long long
using namespace std;
const int N=1e6+1,L=20;
int pre[N],nxt[N],h[N],w[N],idx;
int fa[N][L],dep[N],dist[N],f[N];
int n,m,x,y,ans,st,go,fm,gen;
void add(int x,int y,int z){h[++idx]=y,nxt[idx]=pre[x],w[pre[x]=idx]=z;}
void dfs(int u,int f){
	dep[u]=dep[fa[u][0]=f]+1;
	rep(i,1,L-1)fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int i=pre[u];i;i=nxt[i])if(h[i]!=f)dist[h[i]]=dist[u]+w[i],dfs(h[i],u);
}
int LCA(int x,int y){
	if(dep[x]<dep[y])swap(x,y);
	per(i,L-1,0)if(dep[fa[x][i]]>=dep[y])x=fa[x][i];
	if(x==y)return x;
	per(i,L-1,0)if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
int dis(int x,int y,int Fmu){return dist[x]+dist[y]-2*dist[Fmu];}
int find(int x){return (f[x]==x)?x:f[x]=find(f[x]);}
void color(int x,int Fmu){while(dep[x]>=dep[Fmu])x=find(f[x]=fa[x][0]);}
signed main(){
    cin>>n>>m>>st;
    rep(i,1,n)f[i]=i;
	rep(i,1,n-1)cin>>x>>y,add(x,y,1),add(y,x,1);
	dfs(1,0);
	rep(i,1,m){
		cin>>go;
		if(f[go]==go){
			ans+=dis(st,go,fm=LCA(st,go));
			color(st,fm),color(st=go,fm);
		}
	}
    return cout<<ans,0;
}
```