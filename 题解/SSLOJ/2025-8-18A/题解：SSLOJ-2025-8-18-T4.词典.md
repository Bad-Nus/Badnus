# 题面
[SSLOJ-2025-8-18-T4.词典](../../../题面/SSLOJ题面/2025-8-18A/SSLOJ-2025-8-18-T4.词典.md)

![[../../../题面/SSLOJ题面/2025-8-18A/SSLOJ-2025-8-18-T4.词典]]
# 分析
$trie$ 模板题，多记录每个 $trie$ 节点上个前缀串的下标即可。
# 代码
```
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
#define int long long
using namespace std;
const int N=5e6+1;
char s[N];
int n,m,nxt[N],pre[N],h[N],idx,now;
void add(int x,int y){
	h[++idx]=y;
	nxt[idx]=pre[x];
	pre[x]=idx;
}
int get(char x){return x-'a';}
struct trie{
	int nex[N][3],mx[N],idx=1;
	void insert(char* s){
		int p=1,l=strlen(s),c;
		rep(i,0,l-1){
			c=get(s[i]);
			if(!nex[p][c])nex[p][c]=++idx;
			p=nex[p][c];
			mx[p]=max(mx[p],now-h[pre[p]]-1);
			add(p,now);
		}
	}
	int find(char* s){
		int p=1,l=strlen(s),c;
		rep(i,0,l-1){
			c=get(s[i]);
			if(p)p=nex[p][c];
		}
		if(!p)return n;
		return mx[p];
	}
}T;
signed main(){
	cin>>n>>m;
	rep(i,1,n)now=i,cin>>s,T.insert(s);
	rep(i,1,T.idx)T.mx[i]=max(T.mx[i],n-h[pre[i]]);
	rep(i,1,m)cin>>s,cout<<T.find(s)<<endl;
    return 0;
}
```