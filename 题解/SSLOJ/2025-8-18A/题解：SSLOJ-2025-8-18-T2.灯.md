---
Tags:
  - 题解
---
# 题面
[SSLOJ-2025-8-18-T2.灯](../../../题面/SSLOJ题面/2025-8-18A/SSLOJ-2025-8-18-T2.灯.md)

![[../../../题面/SSLOJ题面/2025-8-18A/SSLOJ-2025-8-18-T2.灯]]
# 分析
给定 $a_i$ ，求最小 $size(Q)\in U$ 即 $\lvert Q\rvert_{min}$ 使 $\displaystyle{g(Q)=\bigoplus_{i\in Q}a_i=(2^n-1)}$

> 官方正解高斯消元，搜索是好想的。爆搜超时，考虑折半。

> 直接将异或和用状压维护起来，对所有 $g(Q_l)\oplus g(Q_r)=(2^n-1)$ ，令 $ans=min(\lvert Q_l\cup Q_r\rvert)$
# 代码
```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
#define int long long
using namespace std;
const int N=1e5+1,M=40;
int ans=INT_MAX,n,m,tmp,x,y;
map<int,int>mp;
vector<int>v[40];
void dfs(int pos,int num,int st){
	if(!pos)return mp[num]=(mp[num]==0&&num!=0?st:min(mp[num],st)),void();
	dfs(pos-1,num,st);
	for(auto to:v[pos])num=(num^(1ll<<(to-1)));
	num^=(1ll<<(pos-1));
	dfs(pos-1,num,st+1);
}
void bfs(int pos,int num,int st){
	if(pos>n){
		tmp=((1ll<<n)-1)^num;
		if(!tmp)ans=min(ans,st);
		else if(mp[tmp]!=0)ans=min(ans,st+mp[tmp]);
		return;
	}
	bfs(pos+1,num,st);
	for(auto to:v[pos])num=(num^(1ll<<(to-1)));
	num^=(1ll<<(pos-1));
	bfs(pos+1,num,st+1);
}

signed main(){
	cin>>n>>m;
	while(m--)cin>>x>>y,v[x].push_back(y),v[y].push_back(x);
	dfs(n/2+0,0,0);
	bfs(n/2+1,0,0);
	return cout<<ans,0;
}
```