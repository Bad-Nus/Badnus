# 题面
[SSLOJ-2025-8-13-T3.简单的玄学](../../../题面/SSLOJ题面/2025-8-13A/SSLOJ-2025-8-13-T3.简单的玄学.md)

![[../../../题面/SSLOJ题面/2025-8-13A/SSLOJ-2025-8-13-T3.简单的玄学]]
# 分析
> 考虑用 $1$ 减去两两不同概率，这个概率用经典的生日悖论计算:

$$\prod_{i=1}^m \frac{2^n-i+1}{2^n}=\frac{\prod_{i=1}^m 2^n-i+1}{2^{nm}}=\frac{(2^n)^{\underline{m}}}{2^{nm}}$$

> 先求分母分子再约分再取模，约分取逆即可，即带模求分母分子
> 
> 分母快速幂求即可，分子似乎不好求，但结合 $mod=1e6+3$ 的小模数进行观察，容易瞪出分子为连续 $m$ 项积，若 $m>=mod$ 则必有一项为 $mod$ 倍数，即分子为 $0$。
> 
> 约分即求分子中 $2$ 因子的个数，即 $2^n-m+1\sim 2^n$ 每一项 $i$ 的 $2$ 因子数和 $\sum cnt(i)$。由于 $n$ 过大导致 $2^n$ 无法探知具体大小，也没有有关 $2$ 因子数的性质。
> 
> 但有个结论(**补证1**)： $\forall 1\le x\lt 2^n,cnt(x)=cnt(2^n-x)$ ，那么问题便转化成求 $cnt((m-1)!)+n$ 。求 $(m-1)!$ 的 $2$ 因子数有经典的 $O(\log m)$ 做法(**补证2**)。
## 补证
### 补证1
> 求一个数因子个数等价于该数二进制下末尾连续 $0$ 数，显然由于 $2^n-x+x=2^n$ 末尾最后一个 $1$ 的位置相同， $1$ 后连续的 $0$ 自然相同。得证。
### 补证2
> 容易得出 $x!$ 的 $2$ 因子个数为 $\sum_{i=1}^{\lceil\log x\rceil} \frac{x}{2^i}$ 。对 $x$ 二进制下的其中一位 $2^k$ 而言，它的贡献为:
$$\sum_{i=1}^k 2^{(k-i)}=\sum_{i=0}^{k-1} 2^i=2^k-1$$

> 设 $n$ 的二进制 $1$ 位置集 $N$ ，由于 $n=\sum 2^k$ ， $n$ 的 $2$ 因子数为贡献和为:
$$\sum_{k\in N}\sum_{i=1}^k 2^{(k-i)}=\sum_{k\in N}(2^k-1)=\sum_{k\in N}2^k-size(N)=n-size(N)$$
> 在代码中用 $x$ 减去 $x$ 二进制 $1$ 位数即 $x!$ 的 $2$ 因子数。
# 代码
```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
#define int long long
using namespace std;
const int mod=1e6+3;
int find(int x){//拆分质数2 
	unsigned int y = static_cast<unsigned int>(x);
	return x - __builtin_popcountll(y);
}
int mi(int x,int y){//快速幂 
	int t=1;
	for(;y;y>>=1,x=x*x%mod)if(y&1)t=t*x%mod;
	return t;
}
int prod(int st,int sum){//暴力求积 
	int t=1;
	rep(i,0,sum-1)t=t*(st+mod/*以防负数*/-i)%mod;
	return t;
}
int n,m,tmp,a,b,inv;
signed main(){
	cin>>n>>m;
	if(n<=64&&(1ll<<n)<m)return puts("1 1"),0;
	//抽屉原理特判 
	tmp=mi(2,n),a=m>=mod?0:prod(tmp,m),b=mi(tmp,m); 
	//原式子
	inv=mi(mi(2,(find(m-1)+n)),mod-2); 
	//gcd(a,b)取逆做带模除法 
	a=a*inv%mod,b=b*inv%mod;
	//约分
	a=(b+mod/*以防负数*/-a)%mod;
	//求补集 
	return cout<<a<<' '<<b,0;
}
```