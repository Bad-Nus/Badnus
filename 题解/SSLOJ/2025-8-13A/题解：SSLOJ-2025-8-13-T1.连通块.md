---
Tags:
  - 题解
---
# 题面
[SSLOJ-2025-8-13-T1.连通块](../../../题面/SSLOJ题面/2025-8-13A/SSLOJ-2025-8-13-T1.连通块.md)

![[../../../题面/SSLOJ题面/2025-8-13A/SSLOJ-2025-8-13-T1.连通块]]
# 分析
> 连通块求解有深搜和并查集两方法，深搜 $O(q(n+m))$ ，并查集 $O(qm\alpha(n))$ 。该题数据水，暴力勉强能过，深搜复杂度和常数更大，需要卡常。
> 
> 思考正解，每次拆掉区间 $[l,r]$ 边后需要重新建并查集。对边，仍是 $O(qm\alpha(n))$ 的。
> 
> 由于枚举 $l,r$ 进行预处理 $O(n^2)$ ，考虑优化。
> 
> 我们知道，并查集 $merge$ 的性质很好 $merge(x,a,b,c,d)$ 等价于 $merge(x,find(merge(a,b,c,d)))$ 
> 
> 那么把整段区间 $[1,n]$ 分成 $[1,l)$ 和 $(r,n]$ 区间后，对两边分别合并，合并后的并查集分别为 $A$ , $B$ ，那么 $\forall i,merge(A_i,B_i)$ 这样可以让预处理从前后缀角度思考
> 
> 预处理前 $j$ 个边和后 $j$ 个边分别构成的并查集 $A_j$ , $B_j$ ，预处理复杂度 $O(nm)$ 。询问 $l,r$ 即合并 $A_{l-1},B_{r+1}$ ，询问复杂度 $O(qn)$ 。
# 代码
## 暴力dfs
```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
using namespace std;
const int N=510,M=2e4+10;
int n,m,q,pre[N],nxt[M],h[M],ord[M],idx,x,y,ans;bool vis[N];
struct nd{int to,ord;};
vector<nd>v[N];
void dfs(int u){for(nd i:v[u])if((i.ord<x||i.ord>y)&&!vis[i.to])vis[i.to]=1,dfs(i.to);}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0),cin>>n>>m;
	rep(i,1,m)cin>>x>>y,v[x].push_back({y,i}),v[y].push_back({x,i});
	cin>>q;
	while(q--){
		memset(vis,0,sizeof vis),ans=0;
		cin>>x>>y;
		rep(i,1,n)if(!vis[i])dfs(i),++ans;
		cout<<ans<<endl;
	}
	return 0;
}
```
## 暴力并查集
```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
using namespace std;
const int N=1e6+1;
struct nd{int x,y;}e[N];
int n,m,x,y,k,l,r,ans,f[N];
void init(){rep(i,1,n)f[i]=i;}
int find(int x){return f[x]==x?x:f[x]=find(f[x]);}
void merge(int x,int y){f[find(x)]=find(y);}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=m;++i)cin>>e[i].x>>e[i].y;
	cin>>k;
	while(k--){
		init(),cin>>l>>r,ans=0;
		rep(i,1,l-1)merge(e[i].x,e[i].y);
		rep(i,r+1,m)merge(e[i].x,e[i].y);
		rep(i,1,n)if(f[i]==i)++ans;
		cout<<ans<<endl;
	}
    return 0;
}
```
## 正解
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=510,M=10010;
struct nd{int x,y;}e[M];
int n,m,x,y,q;
int l,r,ans;
int A[M][N],B[M][N],C[N];
int find(int f[],int x){return f[x]==x?x:f[x]=find(f,f[x]);}
void merge(int f[],int x,int y){f[find(f,x)]=find(f,y);}
void init(){
	for(int i=1;i<=n;++i)A[0][i]=B[m+1][i]=i;
	for(int i=1,k=m;i<=m;++i,--k){
		for(int j=1;j<=n;++j)A[i][j]=A[i-1][j],B[k][j]=B[k+1][j];
		merge(A[i],e[i].x,e[i].y);
		merge(B[k],e[k].x,e[k].y);
	}
}
void solve(){
	for(int i=1;i<=n;++i)C[i]=A[l-1][i];
	for(int i=1;i<=n;++i)merge(C,i,B[r+1][i]);
	for(int i=1;i<=n;++i)if(C[i]==i)++ans;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0),cin>>n>>m;
	for(int i=1;i<=m;++i)cin>>e[i].x>>e[i].y;
	init(),cin>>q;
	while(q--)cin>>l>>r,ans=0,solve(),cout<<ans<<endl;
    return 0;
}
```