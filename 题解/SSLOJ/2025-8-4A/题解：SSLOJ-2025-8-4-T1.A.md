---
Tags:
  - 题解
---
# 题面
[SSLOJ-2025-8-4-T1.A](../../../题面/SSLOJ题面/2025-8-4A/SSLOJ-2025-8-4-T1.A.md)

![[../../../题面/SSLOJ题面/2025-8-4A/SSLOJ-2025-8-4-T1.A|SSLOJ-2025-8-4-T1.A]]
# 分析
## 子任务
### 1.暴力
> 暴力找 $n$ 的倍数，期望 $10\quad pts$
### 2.爆搜
> 因为 $1,11,111,1111...$ 中总有两个模 $n$ 得余数相同。余数相同的直接相减就好，期望 $40\sim 70\quad pts$
### 3.打表
> 打表发现，除了 $99999$ 和 $999999$ 得答案略大，超过 $25$ 位之外。别的位数都不大,跑个 $2^{24}$ 的打表程序即可。期望 $90\sim 100\quad pts$
## 正解
> 由两数成倍数关系, $m>n$ 易想到通过同余定理优化，同余定理优化的前提下进行 $m$ 的构造。
> 
> 有
> $$m\equiv0(mod=n)$$
>
> 那么向前递归,令 $m=10x$或$m=10x+1$,有
> $$x\equiv10^{-1}(m) 或 10^{-1}(m-1)\quad(mod=n)$$
>
> 令 $m=x$,然后再令 $m=10x$ 或 $m=10x+1$,由上式递推直至 $m\equiv 1$ 或再次出现 $m\equiv 0$
>
> 同时我们知道 $10\times 0 +1\equiv 1$,将过程反过来看，应当为(在 $mod=n$ 意义下)
> $$(0\stackrel{\times 10+1/0}{\longrightarrow})1\stackrel{\times 10+1/0}{\longrightarrow}x\stackrel{\times 10+1/0}{\longrightarrow}...\stackrel{\times 10+1/0}{\longrightarrow}0$$
>
> 令 $x=1$,模拟该过程即可,显而易见的发现相同的 $x$ 越小越优,所以可以减枝广搜,向 $x=10x$ 和 $x=10x+1$ 两个方向搜索:
> 
> 遇见之前出现过的模 $n$ 余数相同的 $x$,前者更优,后者不予入列，而是仅走令一个方向。
> 
> ($n$ 的 $01$ 倍数在有限位数内必然有解,且 $m$ 的长度不超过 $n$ 的大小,该减枝不会不至而终。)
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+1;
struct nd{
	int num,lst;
}p[N];
int n,vis[N],x,k;
queue<int>q;
void print(int x){
	if(~x)print(p[x].lst),printf("%d",p[x].num);
}
void in(int x,int a,int b){
	q.push(x),vis[x]=1;
	p[x].lst=a,p[x].num=b;
}
void bfs(){
	in(1,-1,1);
	while(q.size()){
		x=q.front();q.pop();
		if(!x)break;
		k=(x*10+0)%n,(!vis[k])&&(in(k,x,0),0);
		k=(x*10+1)%n,(!vis[k])&&(in(k,x,1),0);
	}
	print(0);
}
int main(){
	scanf("%d",&n);
	if(n==1)cout<<1;
	else bfs();
	return 0;
}
```
