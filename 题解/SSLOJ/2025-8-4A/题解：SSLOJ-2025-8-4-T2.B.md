# 题面
[SSLOJ-2025-8-4-T2.B](../../../题面/SSLOJ题面/2025-8-4A/SSLOJ-2025-8-4-T2.B.md)

![[../../../题面/SSLOJ题面/2025-8-4A/SSLOJ-2025-8-4-T2.B|SSLOJ-2025-8-4-T2.B]]
# 分析
题面：

>给定 $m$ 个长度为 $n$ 的01串，和 $q$ 个查询，每个查询提供一个01串 $s$ 和一个阈值 $k$，要求输出数据库中与 $s$ 的相似值不超过 $k$ 的串的数量。
>
>相似值定义为：若两个串在第 $i$ 位相同，则加上权重 $w_i$。

## 子任务1(20%)
> 直接存储所有数据库串和权重 $w$。然后对于每个查询，扫描所有 $m$ 个数据库串。对于每个数据库串 $t$，计算其与查询串 $s$ 的相似值。
> 
> 时间复杂度： $O(nmq)$。


## 子任务2(50%)
> 状态压缩 + 预处理所有可能状态的前缀和。
> 
> 利用 $n$ 较小（ $n \leq 12$，状态数 $2^n \leq 4096$)，枚举所有可能的01串状态（0 到 $2^n - 1$)。预处理每个状态 $s$ 到所有数据库串的相似值分布，并计算前缀和，使查询可 $O(1)$ 响应。
### **步骤**：
1. **预处理频率数组**：
> 将每个串转换为整数 $t$,记 $\text{freq}[t]$ 为 $t$ 在数据库中出现的次数。
2. **预处理权重数组**：
> 记
		
$$\begin{cases}
W=\sum_{i=1}^n w_i\\
cost[v] = \sum_{i \in \text{v}} w_i\\
sim_{s,t}=W-cost[s\oplus t]
\end{cases}$$

> （ $W$ 即总权重, $cost[v]$ 即整数中二进制位为 $1$ 的位置的权重和,那么对整数 $s$ 和 $t$ 而言相似度 sim 即为总权重减去不同位权重和）

3. **预处理相似值桶和前缀和**：
> 记 $\text{bucket}[s][\text{val}]$ 为对整数 $s$ 而言相似值为 $val$ 的整数对数量。
> 
> $\text{ans}[s][k]$ 为对状态 $s$ 而言相似值不超过 $val$ 的整数对数量。

> 预处理有

$$
\begin{cases}
\text{bucket}[s][\text{sim}_{s,t}] += \text{freq}[t] & {s,t\in [0,2^n-1]}\\
\text{ans}[s][k] = \sum\_{val=0}^k\text{bucket}[s][\text{val}] & {s\in [0,2^n-1]}
\end{cases}
$$

- **时间复杂度**： 预处理： $O((2^n-1)^2)=O(2^{2n})\approx 1.68\times 10^7$ ，查询：$O(q)$ 
- **空间复杂度**： $O(2^n \cdot \text{W})$（约7.4 MB）

## 正解
> 预处理加 $\text{DP}$ (状压+背包)

> **前言：**
> 
> **我们记两个状态直接进行转换的代价有两种：**
>
> 1.相似代价(简称**同价**):我们定义两个串 $s,t$ 之间变换有一个相似代价，即一旦 $s_i=t_i$ ，会为变换积累 $w_i$ 的代价，称为同价。
> 
> 2.变换代价(简称**异价**):我们定义两个串 $s,t$ 之间变换有一个变换代价，即一旦 $s_i\neq t_i$ ，回为变换积累 $w_i$ 的代价，称为异价。
>
> 3. $f_{i,j,k}$ 表示对于一个状态 $j$，只允许改 $[i, n]$ 这几位，且花费不超过 $k$ 的异价和，可以变成多少目标串。
>
> (异价和可以理解为 $j$ 每位取反需要花费 $w_i$ 代价，变成目标串需要的代价和)
> 
> **再记**
>
> 3.对一个串 $s$ 中所有数字进行取反记做 $s$ 的反串 $\sim s$

> 那么显然题中 $s,t$ 两串的相似度等价于$s,t$的同价和，等价于 $\sim s,t$ 的异价和，等价与 $\sim s$ 串花费异价对元素进行取反变成 $t$ 串。
> 
> 设在这 $m$ 个串 $T_j$ 中，有 $ans_s$ 个串 $t$ 和串 $s$ 的相似值不超过 $k$，有


$$\begin{equation}
\begin{split}
ans_s
&=与s串同价和不超过k的串数\\
&=与(\sim s)串异价和不超过k的串数\\
&=f_{1,(\sim s),k}
\end{split}
\end{equation}$$

$$\begin{equation}
\begin{split}
即ans_s
&=\sum_{j=1}^m{{\Huge\color{blue}[}{\Large\color{red}(}\sum_{i=1}^n{{\large\color{green}[}s[i]=t_j[i]{\large\color{green}]}*w_i{\Large\color{red})}\leq k}{\Huge\color{blue}]}}\\
&=\sum_{j=1}^m{{\Huge\color{blue}[}{\Large\color{red}(}\sum_{i=1}^n{{\large\color{green}[}(\sim s[i])\neq t_j[i]{\large\color{green}]}*w_i{\Large\color{red})}\leq k}{\Huge\color{blue}]}}\\
&=f_{1,(\sim s),k}
\end{split}
\end{equation}$$
> 那么我们题目便转化为预处理 $f_{i,j,k}$ 数组，要对$m$个已知串 $t$ 计算贡献。二进制位左大右小，第 $n$ 位为 $2^0$ 位，初始化时记第 $n+1$ 位表示一位也不选，$t$ 花费 $0$ 价值可以变成自身，即初始时有 $f_{n+1,j,(0\sim k)}=cnt_j$。从第 $n$ 位开始向"高位"遍历，对每个状态每位可以花费 $w_i$ 价值令别的 **(第 $i$ 位与本状态相同的串 $t \color{red}{的反串\sim t}$)** 的第 $i$ 位变成 $j$ 的第 $i$ 位。
>
> 那么有便有这样的 $DP$ 转移

$$\begin{equation}
\begin{split}
f_{i,j,k}
&=f_{i+1,j,k}\\
&(+f_{i+1,j\oplus (1<<(i-1)),(k-w_i)})(if\quad k>=w_i)
\end{split}
\end{equation}$$


 - **时间复杂度**： $O(2^n\cdot W) = 32768 \times 451 \approx 1.48 \times 10^7$  
 - **空间复杂度**： $O(2^n \cdot \text{W}) = 32768 \times 451 \approx 1.48 \times 10^7 int$(约59 MB)

# 代码
## 暴力
```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
using namespace std;
const int N=1e6+1;
typedef long long ll;
ll n,m,q,k,a[N];
string w[N],v;
void solve(){
	int ans=0;
	rep(i,1,m){
		ll res=0;
		rep(j,1,n)res+=a[j]*(w[i][j-1]==v[j-1]);
		if(res<=k)++ans;
	}
	cout<<ans<<'\n';
}
int main(){
	cin>>n>>m>>q;
	rep(i,1,n)cin>>a[i];
	rep(i,1,m)cin>>w[i];
	while(q--)cin>>v>>k,solve();
	return 0;
}


```
## 子任务(50%)
```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
using namespace std;

const int N = 13;
const int S = 1<<12;
const int W = 370; // 12*30=360

int n, m, q;
int w[N], freq[S];
int cost[S], ans[S][W];
int total_w;

// 将字符串转换为状态：字符串的第i位对应状态的第i位
inline int read_str() {
    char s[N];
    scanf("%s", s);
    int state = 0;
    rep(i, 0, n-1) {
        if (s[i] == '1')
            state |= (1 << i);
    }
    return state;
}

int main() {
    scanf("%d%d%d", &n, &m, &q);
    
    // 读入权重并计算总权重
    total_w = 0;
    rep(i, 0, n-1) {
        scanf("%d", &w[i]);
        total_w += w[i];
    }
    
    // 读入并统计数据库串频率
    rep(i, 1, m) {
        int state = read_str();
        freq[state]++;
    }
    
    // 预处理每个状态的代价（不同位的权重和）
    int total_states = 1 << n;
    rep(mask, 0, total_states-1) {
        cost[mask] = 0;
        rep(bit, 0, n-1) {
            if (mask & (1 << bit)) {
                cost[mask] += w[bit];
            }
        }
    }
    
    // 预处理相似值分布
    rep(s, 0, total_states-1) {
        // 初始化桶
        vector<int> bucket(total_w+1, 0);
        
        // 枚举所有数据库状态
        rep(t, 0, total_states-1) {
            if (!freq[t]) continue;
            
            int diff = s ^ t;
            int sim = total_w - cost[diff]; // 计算相似值
            
            if (sim >= 0 && sim <= total_w) {
                bucket[sim] += freq[t];
            }
        }
        
        // 计算前缀和
        if (total_w >= 0) {
            ans[s][0] = bucket[0];
            rep(k, 1, total_w) {
                ans[s][k] = ans[s][k-1] + bucket[k];
            }
        }
    }
    
    // 处理查询
    while (q--) {
        int s = read_str();
        int k;
        scanf("%d", &k);
        
        if (k >= total_w) {
            printf("%d\n", m);
        } else {
            printf("%d\n", ans[s][k]);
        }
    }
    
    return 0;
}
```
## 正解
```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
using namespace std;
const int N=20;
int n,m,q,cnt[1<<15],f[N][1<<15][35],w[N],now,bin,x,k;
char ss[N];
int read () {//输入并取反 
	scanf("%s",ss),now=0,bin=1;
	rep(u,0,n-1)ss[u]=='0'||(now|=(1<<u));
	return now;
}
int main() {
	scanf("%d%d%d",&n,&m,&q);
	rep(u,1,n)scanf("%d",&w[u]);
	rep(u,1,m)cnt[read()]++;
	
	for (int u=0; u<(1<<n); u++)
		for (int i=0; i<=30; i++)
			f[n+1][u][i]=cnt[u];
	for (int u=n; u>=1; u--)
		for (int i=0; i<(1<<n); i++)
			for (int j=0; j<=30; j++) {
				f[u][i][j]=f[u+1][i^(1<<(u-1))][j];
				if (j>=w[u])
					f[u][i][j]=f[u][i][j]+f[u+1][i][j-w[u]];
			}
	while (q--) {
		x=read(),scanf("%d",&k);
		printf("%d\n",f[1][x][k]);
	}
	return 0;
}
```
