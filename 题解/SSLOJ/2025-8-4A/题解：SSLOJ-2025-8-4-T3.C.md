---
Tags:
  - 题解
---
# 题面
[SSLOJ-2025-8-4-T3.C](../../../题面/SSLOJ题面/2025-8-4A/SSLOJ-2025-8-4-T3.C.md)

![[../../../题面/SSLOJ题面/2025-8-4A/SSLOJ-2025-8-4-T3.C|SSLOJ-2025-8-4-T3.C]]
# 分析
> 题面简明。设矩阵为 $n\times m(t=nm)$ ，我们知道对点 $(x,y)$ 而言最远点必然在矩阵角，我们钦定最远点 $(n,m)$ ，距离为 $d$ 那么有 $d=(n-x)+(m-y)=n+m-x-y$。
>
> 有一个显然的结论：我们所有数字用哈希或静态数组存储后，设 $mp_v$ 为数字 $v$ 出现的次数。若是距 $(x,y)$ 为 $v(v>0)$ 距离点均未出界，那么有 $mp_v=4v$。 $v$ 遍历 $1\sim n$，首个 $mp_v\neq 4v$的为出界点，那么点 $(x,y)$ 中其中一个坐标即为 $v$，我们钦定 $x=v$。
>
> 那么有 $y=n+m-x-d=n+m-v-d$，枚举 $n,m$ 并验证所有数字是否符合便可。注意 钦定$x=v$ 后 $n$ 与 $m$ 并不等价， $n$ 的枚举不可仅枚举至 $\sqrt{t}$ ，否则被卡。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
int t,a[N],cnt[N],x,y,d;
int main() {
	scanf("%d",&t);
	for (int u=1; u<=t; u++) {
		scanf("%d",&x);
		a[x]++;
		d=max(d,x);
	}
	for (int u=1; u<=t; u++)
		if (a[u]!=(u*4)) {
			x=u;
			break;
		}
	for (int n=1; n<=t; n++)
		if (t%n==0) {
			int m=t/n;
			int y=n+m-x-d;
			if (abs(n-x)+abs(m-y)!=d) continue;
			for (int u=0; u<=n+m; u++) cnt[u]=0;
			for (int u=1; u<=n; u++)
				for (int i=1; i<=m; i++)
					cnt[abs(u-x)+abs(i-y)]++;
			bool tf=false;
			for (int u=0; u<=n+m; u++)
				if (cnt[u]!=a[u]) {
					tf=true;
					break;
				}
			if (tf==false) {
				printf("%d %d\n%d %d\n",n,m,x,y);
				return 0;
			}
		}
	printf("-1");
	return 0;
}
```
