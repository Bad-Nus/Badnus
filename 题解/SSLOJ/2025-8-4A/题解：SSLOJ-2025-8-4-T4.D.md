# 题面
[SSLOJ-2025-8-4-T4.D](../../../题面/SSLOJ题面/2025-8-4A/SSLOJ-2025-8-4-T4.D.md#ssloj-2025-8-4-t4d)

![[../../../题面/SSLOJ题面/2025-8-4A/SSLOJ-2025-8-4-T4.D|SSLOJ-2025-8-4-T4.D]]
# 分析
## 子任务(30%)
> $n\le 10^3,O(n^2)$ 暴力匹配即可。
## 子任务(50%)
> 相同的 $a_i$ 不超过 $1000$ 个，放桶里 $O(1000^2)$ 暴力匹配即可。
## 正解
> 若 $s\land t=0$,那么把 $s,t$ 看做 $01$ 串，定义 $t$ 串所有元素取反的串为 $t$ 的反串 $\sim t$，有
$$\forall s_i=1,有t_i=0 \iff \forall s_i=1,有(\sim t)_i=1$$

> 再定义将一个串的若干个 $1$ 变成 $0$得到的所有新串成为该串的子串。
> 
> 那么将 $\sim t$ 的若干个子串中，必然有一个与 $s$ 相同。将所有已知串取反后并标记，再预处理出这些串的所有子串并标记。

> 最后再遍历所有串，询问自身是否被标记便知是否存在 $s\land t=0$。
# 代码
## 正解
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005,M=1048576;
int a[N],h[M+10],n,m=M-1;
int main() {
	scanf("%d",&n);
	for(int u=1;u<=n;u++){
		scanf("%d",&a[u]);
		h[a[u]^m]=1;
	}
	for(int u=m;u>=0;u--)
		if(h[u])
			for(int i=0;i<20;i++)
				if((u&(1<<i))!=0)
					h[u^(1<<i)]=1;
	for(int u=1;u<=n;u++)printf("%d ",h[a[u]]);
	return 0;
}

```
