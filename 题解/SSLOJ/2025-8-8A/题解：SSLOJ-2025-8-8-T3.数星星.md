---
Tags:
  - 题解
---
# 题面
[SSLOJ-2025-8-8-T3.数星星](../../../题面/SSLOJ题面/2025-8-8A/SSLOJ-2025-8-8-T3.数星星.md)

![[../../../题面/SSLOJ题面/2025-8-8A/SSLOJ-2025-8-8-T3.数星星|SSLOJ-2025-8-8-T3.数星星]]
# 分析
## 子任务1
$n<=20,O(2^n)$ 或 $O(n\times 2^n)$ 暴力均可
## 子任务2
$r=1$，无限制，答案为 $\binom n k$。
## 正解
题意简化:

> 一个 $01$ 组成的 $n$ 元数组 $a$ 中 $1$ 数为 $k$，最短连续 $1$ 长度至少 $r$。求方案数。

(由 $n\leq 1e7$ 知 $O(n)$ 可以接受。由子任务知答案有关组合数，考虑数学。)

考虑 $1$ 的位置，隔板法，即考虑放回 $k$ 个 $1$ 回到全$0$序列。

由于至少 $r$ 个连续 $1$ 的限制，一个普遍的思路便是提前组成 $k$ 连数，将 $k$ 连数看做一个数并放回。

又由于我们不清楚具体多少个 $r$ 连数，仅仅假定 $1$ 个然后剩下的 $k-r$ 个去随机放时，假设其中一个方案有多个 $r$ 连数，方案会记重复，需要用容斥定理将重复方案去除。

我们设 $1$ 的至少连数最多有 $t$ 个且我们视他们有序，定义所有第 $i$ 个 $1$ 连数为至少 $r$ 连数的方案的集合为 $A_i$，那么我们要求的便是 $\bigcup_{i=1}^t A_i$，根据容斥，若 $B=\{A_1,A_2...A_i\}$ ，有
$$\bigcup_{i=1}^t A_i=\sum_{C\subseteq B}(-1)^{size(C)-1}\bigcap_{e\in C}e$$
令 $size(C)=j$ 即有 $j$ 个至少 $r$ 连数，隔板法放进 $(0数量+1)$ 个隔板即 $n-k+1$ 个隔板，有 $\binom{n-k+1}{j}$ 种放法。

那么 $n$ 个数中共有至少 $jr$ 个数已经确定为 $1$，剩下的 $(n-jr)$ 个位置中放 $(k-jr)$ 个 $1$，剩余的 $(n-jr)-(k-jr)=n-k$ 个位置为 $0$，即有下式表示放法数量: ([隔板法](../../../学习笔记/信竞学习笔记/信竞数学/组合数.md#隔板法)中的 $\binom{n+k-1}{n}$ )
$$\binom{剩余星星+隔板数-1}{\text{剩余星星}}=\binom{(n-k+1)+(k-jr)-1}{k-jr}=\binom{n-jr}{k-jr}=\binom{n-jr}{(n-jr)-(k-jr)}=\binom{n-jr}{n-k}$$

(隔板法看，有$(0数量+剩余星星数-1)$个隔板，式子同理)

又 $jr\leq k \Rightarrow j\leq \frac k r\Rightarrow j\leq \lfloor \frac k r\rfloor\Rightarrow (t\leftarrow\lfloor \frac k r\rfloor)$，有
> $$cnt(\bigcup_{i=1}^t A_i)=cnt(\bigcup_{i=1}^{\lfloor \frac k r\rfloor} A_i)=\sum_{j=1}^{\lfloor \frac k r\rfloor}(-1)^{j-1}\cdot\binom{n-k+1}{j}\binom{n-jr}{n-k}$$
## tips
实现细节方面，先线性求 $1!\sim n!$，再线性求 $1!\sim n!$ 的逆元。

然而，按 $1\sim n$ 顺序求 $1!\sim n!$ 的逆元是 $O(n\log n)$ 的，或需要多预处理 $1\sim n$ 的逆元才能 $O(n)$，因为 $$(i!)^{-1}=[(i-1)!]^{-1}\times (i)^{-1}$$

而 $n\backsim 1$ 顺序求是直接 $O(n)$ 的，因为 
$$(i!)^{-1}=[(i+1)!]^{-1}\times (i+1)$$
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e7+1,mod=1e9+7;
typedef long long ll;
int n,k,r,fac[N],ifac[N],t,op=1;
ll ans;
int mi(int x,int y){
	int t=1;
	for(;y;y>>=1,x=(ll)x*x%mod)if(y&1)t=(ll)t*x%mod;
	return t;
}
int C(int x,int y){
	if(y>x)return 0;
	return (ll)fac[x]*ifac[x-y]%mod*ifac[y]%mod;
}
void init(){
	fac[0]=ifac[0]=1;
	for(int i=1;i<=n;++i)fac[i]=(ll)fac[i-1]*i%mod;
	ifac[n]=mi(fac[n],mod-2);
	for(int i=n-1;i>=1;--i)ifac[i]=(ll)ifac[i+1]*(i+1)%mod;
}
int main(){
	cin>>n>>k>>r,t=k/r;
	
	init();
	
	for(int i=1;i<=t;++i,op*=-1)ans+=(ll)C(n-k+1,i)*C(n-i*r,n-k)%mod*op;
	
	cout<<(ans%mod+mod)%mod;
    return 0;
}
```
