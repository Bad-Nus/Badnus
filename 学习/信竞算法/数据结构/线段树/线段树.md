# 线段树
基于分治思想，**线段树**结构诞生，可以**动态**地维护区间查询和修改**符合半群结构的信息和修改操作**。

我们先详细解释为什么需要线段树，然后讲解线段树思路，最后从分治和群论的角度剖析线段树代码的构建。

前置知识：分治，群论-半群

在式子中，为了方便，在 $p=[l,r]$ 时记：

$$
\begin{cases}
mid=\lfloor\frac{l+r}{2}\rfloor\\
ls=\operatorname{leftson(p)}=[l,mid]\\
rs=\operatorname{rightson(p)}=[mid+1,r]
\end{cases}
$$
## 查询
### 怎么查询
对于区间 $[l,r]$ 的查询，我们如果每次查询都需要知道 $[l,r]$ 的每个节点的信息，那么一次查询复杂度是 $O(n)$ 的，我们考虑结合半群信息的性质做优化。

对支持合并的半群信息 $(D,\odot)$ 的查询，对 $p=[l,r]$ 区间，设 $d_p=d_{[l,r]}$ 表示 $[l,r]$ 区间的信息并：

$$
\begin{split}
d_1\odot (d_2\odot d_3)&=(d_1\odot d_2)\odot d_3\\
&\Downarrow\\
d_{p}=\bigodot_{l}^{r} d&=\Bigg(\bigodot_{l}^{mid} d \Bigg)\odot \Bigg(\bigodot_{mid+1}^{r} d\Bigg)
\end{split}
$$

（应当注意到，半群信息不具有交换律，所以运算中每一步都是计算**当前项**与**相邻项**的并，不能跨过相邻项进行运算。）

我们观察到这个式子具有子问题性质，也就是可以使用分治优化。

也就是对区间 $p=[l,r]$ 的信息，我们只要知道其子区间 $ls$ 和 $rs$ 的信息即可分治解决，对这两个子区间再进一步分治解决即可，然后我们就可以分治预处理了。

### 怎么预处理

我们可能可以想到枚举区间起点，也就是 ST 表。

ST 表告诉我们对每个 $i$ ，可以预处理长度为 $2^k\big(\forall k\in[0,\log_2 n]\big)$ 的区间 $[i,i+2^k-1]$ 的信息并。

然后对长度为 $k=r-l+1$ 的区间 $[l,r]$ 的信息并。只要用子区间 $[l,l+2^{\log_2\lfloor k\rfloor}-1]$ 和 $[r-2^{\log_2\lfloor k\rfloor}+1,r]$ 的信息并合并即可。

我们考虑这样是否可行：

1. ST 表的信息并区间可交，但半群信息并不满足该性质，所以即便没有高效修改的需求也没办法正常地解决半群信息并的维护。
2. 支持 $O(\log_2{n})$ 查询，但修改是一次重新预处理，是 $O(n\log_2{n})$ 的（线段树修改的复杂度 $O(\log_2 n)$ 后讲）。

因此，ST 表不可行，我们在 ST 表失败的基础上反思做法：

1. 既然信息并要求区间不交，我们预处理的信息同为第 $k$ 层的信息之间就不要产生交集。
2. 修改所影响的区间数量要尽可能的小，容易想到区间不交的前提下，修改时尽可能地取更少的更大区间用以修改。

我们对长度为 $2^k\big(\forall k\in[0,\log_2 n]\big)$ 的区间，尝试只维护 $\lfloor\frac{n}{2^k}\rfloor$ 个保证不交，然后我们所有维护的信息就会变成这样（图片搜集于 [csdn世真](https://blog.csdn.net/CegghnnoR/article/details/128768740)）：

![线段树形态.png](https://www.helloimg.com/i/2025/11/24/69244b220dbe6.png)

我们继续观察到：对所有属于 $[l,r]$ 的子区间 $[t\times 2^k,(t+1)\times 2^k]\in[l,r]$ ，他们的形态是这样的（以 $[l,r]=[3,7]$ 为例）：

![线段树形态2.png](https://www.helloimg.com/i/2025/11/24/69244bf8ec728.png)

然后我们尝试用最少的不交区间（图中标红）来覆盖 $[l,r]$ ：

![线段树形态3.png](https://www.helloimg.com/i/2025/11/24/69244bf7e6b67.png)

如此就可以用这些标红的区间来合并得到 $[l,r]$ 区间的信息并。

考虑复杂度，我们通过一定的观察注意可以发现：

>  对每个 $k\in[0,\log_2 n]$ 所需要的区间不超过两个，否则必然合并成更大的区间。

那么需要查询信息并的区间，最多数量即为 $O(2k)=O(2\log_2 n+2)=O(2\log_2 n)=O(\log_2 n)$ ，这是求信息并的复杂度。

### 怎么实现

那么这些区间怎么找到呢，查找的复杂度又是多少呢？

我们不难发现，我们所预处理的信息有个很好的性质，既然每个区间对应的直接子区间只有两个，可以想到，每个区间对其直接子区间建单向边的话，会恰好形成二叉树，在二叉树上查找即可。

#### 构建 

我们考虑运用这个性质，以二叉树的形态建立一棵树，图中的每个区间很像一条条长线段，因而称为线段树。

由于有 $k=(\log_2 n)+1$ 层，在二叉树中**最多**有 $2^{k+1}-1=4n-1$ 个节点（没用到的节点补全的情况下）。

因为这个性质，大部分时候可以直接开一个四倍空间( $4n$ )的结构体的线性满二叉树（也就是二叉堆）存储。

当然有些需要动态开点（后讲）的时候需要树形结构存储。

那么根据二叉树的性质，我们做深搜，对每个**叶子节点**赋予**原数组中的信息**，再层层递归地对每个节点维护信息并即可。这是一个从子节点向上贡献的过程。

构建的复杂度是节点的数量 $O(n)$ ，因为每个节点恰好在维护贡献时被遍历一次。
#### 寻找

在这棵树上查询 $p=[l,r]$ 区间的信息并，受上文 **"找到所有（属于 $[l,r]$ ）的子区间"** 的启发，我们从树根开始深搜，当前的子树代表的区间完全属于 $[l,r]$ 区间时停下即可，这样便可以不重不漏地找到所有需要的区间了。

我们定义令递归终止的区间称为终止区间，否则为路径区间。

考虑复杂度，对终止节点即最终查询信息的区间，我们上文已经证明是 $O(2\log_2 n)$ 的。

再考虑路径节点的数量，我们发现考虑过程其实是与终止节点的证明类似的：

>  由于同层的路径节点之间必然是**横向连续**的，若同层出现了 $2$ 个以上路径区间，那么除了左右两个区间，中间的所有区间必然可以向上合并成更大区间。

所以，每层路径节点不超过 $2$ 个，总数量是 $O (2 k)=O (2\log_2 n+2)=O (2\log_2 n)=O (\log_2 n)$ 的。

综上，总递归深搜复杂度是 $O(\log_2 n)$ 的。

最后将所有终止区间的信息之并，就是区间 $[l,r]$ 的信息并。
### 代码实现
结合代码来理解上述的思考过程即可，不能完全死背模板。
#### 线段树结构
```cpp
//左右儿子及中点
#define ls(p) (p<<1)
#define rs(p) (p<<1|1)
#define mid ((pl+pr)>>1)
//数据范围
const int N=1e5+10;
//各种原始数据
int a[N],b[N]/*,c[N],...,z[N]*/;

//表示查询所需要的信息的结构体，用于返回查询结果
struct DAT{
	int x,y/*,...等需要的信息*/;
	bool operator+(const Node a)const{
		DAT res;
		res=/*将两个所需信息结构体的信息合并*/;
    	return res;
    }
};
//二叉堆存储表示信息内容的结构体
struct Node{
    int sum,...,ans;//信息的各种细节参数
    //这里定义Node.ans()是我们下面要查询的信息内容
    DAT ans(){return {/*通过各种信息参数得到所需要信息内容的式子*/};}
    bool operator+(const Node a)const{
    	Node res;
		res=/*将两个所需信息结构体的信息合并*/;
    	return res;
    }
}tree[N<<2];
```
#### 构建
```cpp
//合并区间 p 的子区间信息
void pushup(int p){tree[p]=tree[ls(p)]+tree[rs(p)];}
//建树(用build(1,1,n)来建树，表示建到区间 p=[pl,pr])
void build(int p,int pl,int pr){
//到达叶子节点赋值
    if(pl==pr)return tree[p]=Node{/*信息结构体中的细节参数*/},void();

//分治 p 的子区间建树
	build(ls(p),pl,mid),build(rs(p),mid+1,pr);

//合并 p 的子区间结果
    pushup(p);
}
```
#### 寻找
```cpp
//查询[l,r]区间，目前到达的区间为区间p=[pl,pr]
DAT ask(int l,int r,int p,int pl,int pr){
//完全无交集
    if(l>pr||pl>r)return 0;

//完全包含，即终止节点，返回查询所需要的信息求并
    if(l<=pl&&pr<=r)return tree[p].ans();

//否则该节点为路径节点,继续向下查询
    return (ask(l,r,ls(p),pl,mid)+ask(l,r,rs(p),mid+1,pr));
}
```

## 修改
### 疑惑
1. 修改操作暴力维护信息显然不可行，同样需要考虑在树结构信息上分治修改再维护信息并，怎么做呢？
2. 我们发现我们上面的结构式设计用以维护半群的**信息**的，操作怎么应用到信息上呢？
3. 我们上面的定义中提到了**半群的修改操作**，操作怎么能称作是**半群的信息**呢？

这也是线段树令萌新感到费解的地方，下面将逐个解答这些问题。
### 怎么维护对区间的作用
首先有个前置思想，就是我们对信息进行修改后，必然要**先**将自己的修改后的值再层层向上贡献来维护信息并的封闭性（即此刻的正确性），以此来保证下次修改操作使用的是正确的信息。

但如果修改本质仍停留在单点修改上，将毫无进展，因为操作单点的复杂度是 $O(n)$ 的，我们考虑怎么做区间修改的优化。

事实上，根据经验和半群的优良性质，我们认为所有的半群区间操作，都能设计出至少一种，能够**直接计算出**对区间的**作用**从而得到**修改后的区间信息并**，而不借助任何递归的函数，我们称之为**作用函数**。

即对区间长度为 $L=r-l+1$ 的区间 $[l,r]$ ，$T$ 对其的**作用**为：

$$\operatorname{apply}:T_{L}(D)\to D$$

对信息的**作用** (apply) 有 $T_L: D\to D$ ，即对区间 $p=[l,r]$ ，有 $t_{L}(d_{p})=d'_{p}$
### 怎么分治区间作用
对区间 $p=[l,r]$ 进行作用，看似上面通过**作用函数**已经解决了问题，但在线段树上都是可能并没有 $[l,r]$ 这样的完整区间可以直接作用，怎么办？

不妨思考区间修改是否具有子问题性质，即对 $p=[l,r]$ 区间的修改作用是否等价于对子区间 $ls$ 和 $rs$ 的修改作用？

答案是：这是等价的，因为操作具有半群性质，具有结合律。

然后用**作用函数**计算分别对子区间的作用，将作用并起来就等价于对 $p=[l,r]$ 区间的作用，设该操作半群为 $(T,\times)$ ，则满足：

$$
\begin{split}
t_1\times(t_2\times t_3)&=(t_1\times t_2)\times t_3\\
&\Downarrow\\
\bigtimes_{l}^{r} t&=\Bigg(\bigtimes_{l}^{mid} t \Bigg)\times \Bigg(\bigtimes_{mid+1}^{r} t\Bigg)
\end{split}
$$

那么将修改作用到区间 $p=[l,r]$ 上，参考前面做查询的思考过程，可以通过找到覆盖 $[l,r]$ 的最少不交子区间，将这个修改作用在这些区间上即可。

但注意，目前为止的修改做法是存在错误的，下面懒标记中将提到这个错误并将其解决。
### 懒标记
懒标记的思想与代码设计也是萌新头疼的一点。

为什么需要懒标记呢？我们会发现，如果只作用于覆盖 $[l,r]$ 的最少不交子区间，实际上没有达到真正的信息封闭。

我们假设目前对 $[l,r]=[3,7]$ 进行了区间修改操作，我们仔细观察下面的图，会发现这些**粉色**的区间的信息本应该受到作用，但却因为上面的**红色**的祖先区间受到了作用而被我们选择性忽视：

![线段树形态4.png](https://www.helloimg.com/i/2025/11/25/692594c8c39f9.png)

我们考虑这是否会有影响，我们会发现，当我们查询 $[\le 4,4],[5,5],[6,6],[7,\ge 7]$ 这些区间都会直接访问到这些粉色区间，此时信息不封闭导致错误。

那怎么办，你可能会想到每次修改完干脆把信息传到底，然后喜获 TLE 。因为这样实际上又退化成了单点修改，那怎么办，那怎么办？

我来助你，可以考虑修改的时候只传到终止区间，**把所有这样的修改攒在终止区间称为标记**：

在需要**查询到该区间的子区间的时候**：
1. 下传标记：再**将标记的修改作用于子区间**同时**将标记传下去**。(维护了信息封闭，这个不能漏，需要深刻理解记忆)
2. 清空标记：然后**清空该区间的标记(以免重复作用于子区间)。
3. 返回信息并：如果是**终止区间**向上返回自身信息并，如果是**路径区间**先**继续递归查询子区间**再**求子区间的信息并**。

在需要**修改到该区间的子区间的时候**：
1. 下传标记：再**将标记的修改作用于子区间**同时**将标记传下去**。(维护了信息封闭，这个不能漏，需要深刻理解记忆)
2. 清空标记：然后**清空该区间的标记 (以免重复作用于子区间)。
3. 维护信息并：如果是终止区间将作用函数的信息赋值给该区间，如果是**路径区间**将子区间的信息并赋值给该区间。

这就是**懒标记思想**，就是标记下区间的修改，需要时再传下去维护，后面将细节地讲解具体步骤。

这样做正确性是必然的，因为我们赶在查询信息之前维护了**需要查询的那部分的信息**的封闭性。

考虑复杂度，因为修改时没管，查询的时候刚好问什么就把什么临时维护好。所以**带懒标记的查询**是与**普通查询**相同复杂度的 $O(\log_2 n)$。
#### 懒标记的存储
考虑怎么攒着等待下传，我们令每个区间 $p=[l,r]$ 初始时都有一个**标记** $T_{p}=e$ 表示存储下来的所有操作，$e$ 表示单位操作，即对信息无作用。

那么每次 $[l,r]$ 作为一次修改 $t_i$ 的**终止区间**，都要将修改作用攒下来，即：

$$T_{p}\to T_{p}\times t_i$$

如果需要攒多次，我们假设 $p=[l,r]$ 幸运地是 $n$ 次修改的每次修改的终止区间，有：

$$
\begin{split}
t_1(t_2(d_{p}))&=(t_1\times t_2)(d_{p}))\\
&\Downarrow\\
t_1(t_2(...t_n(d_{p})))&=(\bigtimes_{i=1}^n t)(d_{p})\\
&\Downarrow\\
T_{p}&=\bigtimes_{i=1}^n t
\end{split}
$$

那么每次修改时，递归到终止区间 $p=[l,r]$ 时维护这个 $T_{p}$ 即可
#### 懒标记的下传与清空
考虑怎么下传，当查询到该区间 $p=[l,r]$ 且区间 $[l,r]$ 并不是终止区间时，需要：

1. 先**作用于子区间**
2. 同时**下传标记**
3. 再**清空自身标记**

那么有：

$$
\begin{cases}
d_{ls}\to T_{p}(d_{ls})\\
d_{rs}\to T_{p}(d_{rs})\\
T_{ls}\to T_{ls}\times T_{p}\\
T_{rs}\to T_{rs}\times T_{p}\\
T_{p}=e
\end{cases}
$$

然后向两个子树递归重复标记的下传操作，直到到达终止区间，先查询信息并，再向上返回信息并。
### 代码

结合代码来理解上述的思考过程即可，不能完全死背模板。

```cpp

```