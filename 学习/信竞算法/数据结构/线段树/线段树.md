# 线段树
基于分治思想，线段树结构诞生，可以动态地维护区间查询和修改。我们先详细解释为什么需要线段树，再从分治和群论的角度剖析线段树代码的构建。

前置知识：分治，群论
## 查询
对于区间 $[l,r]$ 的查询，我们如果每次查询都需要知道 $[l,r]$ 的每个节点的信息，那么一次查询复杂度是 $O(n)$ 的。

我们考虑预处理信息，但是对任意区间 $[l,r]$ 的信息直接通过枚举来预处理，无论空间还是时间都是 $O(n^2)$ 的。

我们学习了分治思想后，我们会知道：

>  对区间 $[l,r]$ 的信息，我们只要知道其子区间 $[l,mid(l,r)]$ 和 $[mid(l,r)+1,r]$ 的信息即可  

然后对这两个子区间，我们再分别进行上面的两个过程即可。

对于符合半群性质的信息 $d\in D$ ，我们设信息合并的符号为 $\odot$：

$$
\begin{split}
d_1\odot (d_2\odot d_3)&=(d_1\odot d_2)\odot d_3\\
&\Downarrow\\
\bigodot_{l}^{r} d&=\Bigg(\bigodot_{l}^{mid(l,r)} d \Bigg)\odot \Bigg(\bigodot_{mid(l,r)+1}^{r} d\Bigg)
\end{split}
$$

这样将区间 $[l,r]$ 的**信息并的查询**转化为对子区间的**信息并的查询**，然后我们就可以分治预处理。

我们可能想到枚举区间起点，也就是 ST 表。ST 表告诉我们对每个 $i$ ，可以预处理 $\forall k\in[0,log_2(n)]$ 的区间 $[i,i+2^k-1]$ 的信息并，这样可以支持 $O(\log{n})$ 查询，但每次修改是 $O(n\log{n})$ 的，难以优化。

所以转化思路，我们对整体进行分治，也就是枚举区间长度 $\forall k\in[0,log_2(n)]$ ，维护长度为 $\frac{n}{2^k}$ 的 $2^k$ 个区间。这样无论查询还是修改，用二进制倍增的思路拼成区间 $[l,r]$ 即可，查询和修改都最多要找 $O(\log{n})$ 个区间即可。