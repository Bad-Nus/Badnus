# 线段树
基于分治思想，线段树结构诞生，可以动态地维护区间查询和修改**符合半群结构的信息和修改操作**。

我们先详细解释为什么需要线段树，再从分治和群论的角度剖析线段树代码的构建。

前置知识：分治，群论-半群
## 查询
### 怎么查询
对于区间 $[l,r]$ 的查询，我们如果每次查询都需要知道 $[l,r]$ 的每个节点的信息，那么一次查询复杂度是 $O(n)$ 的，我们考虑结合半群信息的性质做优化。

对支持合并的半群信息 $(D,\odot)$ 的查询：

$$
\begin{split}
d_1\odot (d_2\odot d_3)&=(d_1\odot d_2)\odot d_3\\
&\Downarrow\\
\bigodot_{l}^{r} d&=\Bigg(\bigodot_{l}^{mid(l,r)} d \Bigg)\odot \Bigg(\bigodot_{mid(l,r)+1}^{r} d\Bigg)
\end{split}
$$

我们观察到这个式子具有子问题性质，也就是可以使用分治优化。

也就是对区间 $[l,r]$ 的信息，我们只要知道其子区间 $[l,mid(l,r)]$ 和 $[mid(l,r)+1,r]$ 的信息即可分治解决，对这两个子区间再进一步分治解决即可，然后我们就可以分治预处理了。

### 怎么预处理

我们可能可以想到枚举区间起点，也就是 ST 表。

ST 表告诉我们对每个 $i$ ，可以预处理长度为 $2^k\big(\forall k\in[0,\log_2 n]\big)$ 的区间 $[i,i+2^k-1]$ 的信息并。

然后对长度为 $k=r-l+1$ 的区间 $[l,r]$ 的信息并。只要用子区间 $[l,l+2^{\log_2\lfloor k\rfloor}-1]$ 和 $[r-2^{\log_2\lfloor k\rfloor}+1,r]$ 的信息并合并即可。

我们考虑这样是否可行：

1. ST 表的信息并区间可交，但半群信息并不满足该性质，所以即便没有高效修改的需求也没办法正常地解决半群信息并的维护。
2. 支持 $O(\log_2{n})$ 查询，但修改是一次重新预处理，是 $O(n\log_2{n})$ 的（线段树修改的复杂度 $O(\log_2 n)$ 后讲）。

因此，ST 表不可行，我们在 ST 表失败的基础上反思做法：

1. 既然要求区间不交，我们预处理的信息同 $k$ 层之间就不要产生交集。
2. 修改所影响的区间数量要尽可能的小，容易想到区间不交的前提下，修改时尽可能地取更少的更大区间用以修改。

我们对长度为 $2^k\big(\forall k\in[0,\log_2 n]\big)$ 的区间，尝试只维护 $\lfloor\frac{n}{2^k}\rfloor$ 个保证不交，然后我们所有维护的信息就会变成这样（图片搜集于 [csdn世真](https://blog.csdn.net/CegghnnoR/article/details/128768740)）：

![线段树形态.png](https://www.helloimg.com/i/2025/11/24/69244b220dbe6.png)

我们继续观察到：对所有属于 $[l,r]$ 的子区间 $[t\times 2^k,(t+1)\times 2^k]\in[l,r]$ ，他们的形态是这样的（以 $[l,r]=[3,7]$ 为例）：

![线段树形态2.png](https://www.helloimg.com/i/2025/11/24/69244bf8ec728.png)

然后我们尝试用最少的不交区间（图中标红）来覆盖 $[l,r]$ ：

![线段树形态3.png](https://www.helloimg.com/i/2025/11/24/69244bf7e6b67.png)

如此就可以用这些标红的区间来合并得到 $[l,r]$ 区间的信息并。

我们通过一定的证明可以得到，对每个 $k\in[0,\log_2 n]$ 所需要的区间不超过两个，否则必然合并成更大的区间，那么最多需要的区间数量即为 $O(2k)=O(2\log_2 n+2)=O(2\log_2 n)=O(\log_2 n)$ ，这是求信息并的复杂度。

### 怎么实现

那么这些区间怎么找到呢，查找的复杂度又是多少呢？

我们不难发现，我们所预处理的信息有个很好的性质，既然每个区间对应的直接子区间只有两个，可以想到，每个区间对其直接子区间建单向边的话，会恰好形成二叉树。

#### 构建 

我们考虑运用这个性质，以二叉树的形态建立一棵树，图中的每个区间很像一条条长线段，因而称为线段树。

由于有 $k=(\log_2 n)+1$ 层，在二叉树中**最多**有 $2^{k+1}-1=4n-1$ 个节点（没用到的节点补全的情况下）。

有这个性质大部分时候可以直接开一个四倍空间( $4n$ )的结构体的线性满二叉树（也就是二叉堆）存储。

当然有些需要动态开点（后讲）的时候需要树形结构存储。

那么根据二叉树的性质，我们做深搜，对每个叶子节点赋予原数组中的信息，再层层递归地对每个节点维护信息并即可。这是一个从子节点向上贡献的过程。

构建的复杂度是节点的数量 $O(n)$ ，因为每个节点恰好维护贡献时被遍历一次。

注意这个维护信息并的操作以后修改时也会用到，是分治操作的**精髓**。
#### 寻找

在这棵树上查找 $[l,r]$ 区间，受上文 **"找到所有（属于 $[l,r]$ ）的子区间"** 的启发，我们从树根开始深搜，当前的子树代表的区间完全属于 $[l,r]$ 区间时停下即可，这样便可以不重不漏地找到所有需要的区间了。

我们考虑这个复杂度，终止节点我们上文已经证明是 $O(2\log_2 n)$ 的了，我们考虑路径节点的数量即可，我们发现考虑过程其实是与终止节点的证明类似的：

我们发现每层所需要的路径节点不超过 $2$ 个，由于路径节点之间必然是连续的，如果同层出现了 $2$ 个以上路径节点，那么中间的所有节点必然归为终止节点。所以路径节点数量也是 $O (2 k)=O (2\log_2 n+2)=O (2\log_2 n)=O (\log_2 n)$ 的。

综上，总递归深搜复杂度是 $O(\log_2 n)$ 的。
### 实现
结合代码来理解上述的思考过程即可，不能完全死背模板。
#### 树结构
```cpp
//左右儿子及中点
#define ls(p) (p<<1)
#define rs(p) (p<<1|1)
#define mid ((pl+pr)>>1)
//数据范围
const int N=1e5+10;
//原始数据
int a[N];
//二叉堆
struct Node{
    int sum;
}tree[N<<2];
```
#### 构建
```cpp
//合并子区间结果
void pushup(int p){tree[p].sum=tree[ls(p)].sum+tree[rs(p)].sum;}
//建树(用build(1,1,n)来建树)
void build(int p,int pl,int pr){
//叶子节点赋值
    if(pl==pr)return tree[p].sum=a[pl],void();
//分治其子区间
    build(ls(p),pl,mid),build(rs(p),mid+1,pr);
//合并子区间结果
    pushup(p);
}
```
#### 寻找
```cpp
//查询[l,r]
ll ask(int l,int r,int p,int pl,int pr){
//完全无交集
    if(l>pr||pl>r)return 0;
//完全包含，即终止节点
    if(l<=pl&&pr<=r)return tree[p].sum;
//否则该节点为路径节点,继续向下查询
    return (ask(l,r,ls(p),pl,mid)+ask(l,r,rs(p),mid+1,pr));
}
```

## 修改

对于修改操作的维护，我们同样知道暴力枚举在维护信息不可行，同样需要考虑在树结构信息上分治修改再维护信息并。

我们发现我们上面的结构式设计用以维护半群的**信息**的，操作怎么应用到信息上呢？我们上面的定义中提到了**半群的修改操作**，操作怎么能称作是**半群的信息**呢？下面将逐渐揭开这些问题，回收伏笔。

首先有个前置思想，就是我们对信息进行修改后，必然要**先**将自己的修改后的值再层层向上贡献来维护信息并的封闭性（即此刻的正确性），以此来保证下次修改操作使用的是正确的信息。

但这样在树上更新贡献，再从子节点向上重新计算贡献的操作也是 $O(n)$ 的，考虑优化。

我们明白，如果我们的修改仍然停留在单点修改上，那么将毫无进展，我们考虑怎么做区间修改。

我们不妨思考，这个区间修改要做分治的话是否具有子问题性质，即对 $[l,r]$ 区间的修改是否等价于对子区间 $[l,mid(l,r)]$ 和 $[mid(l,r)+1,r]$ 的修改，这显然是等价的。（显然性的证明吗，实在不行我后面有时间再补证吧...）

那么我们不妨将修改看做一种特殊的信息，这就是其拥有来半群性质。

将修改赋予到区间 $[l,r]$ 上，参考前面的思考过程，可以找到覆盖 $[l,r]$ 的最少不交子区间，将这个信息贡献在这些节点上即可，由半群信息的定义**这个过程**与**将这个信息贡献在 $[l,r]$ 中的所有单点**是等价的，接下来就是维护这个半群信息对区间的贡献了。