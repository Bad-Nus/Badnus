# 字符串匹配问题

## 定义

又称模式匹配（pattern matching）。该问题可以概括为「给定字符串 $S$ 和 $T$ ，在主串 $S$ 中寻找子串 $T$ 」。字符 $T$ 称为模式串（pattern）。

## 类型

- **单串匹配**：给定一个模式串和一个待匹配串，找出前者在后者中的所有位置。
- **多串匹配**：给定多个模式串和一个待匹配串，找出这些模式串在后者中的所有位置。
- **其他类型**：例如匹配一个串的任意后缀，匹配多个串的任意后缀……

部分情况可将多个待匹配串时直接连成一个待匹配串处理，效率更高。
## 暴力

简称 BF (Brute Force) 算法，取主串 $S$ 的所有后缀 $suf_i$ ，判断模式串是否是 $suf_i$ 的前缀。

实现如下：
```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(auto u=x;u<=y;++u)
using namespace std;
const int N=1e6+10;
vector<int>BFmatch(char *s,char*t,int n,int m){
    vector<int>ans;
    rep(i,0,n-m)rep(j,0,m-1){
        if(s[i+j]!=t[j])break;
        if(j==m-1)ans.push_back(i);
    }
    return ans;
}
int n,m;
char a[N],b[N];
int main(){
    cin>>n>>m>>a>>b;
    vector<int>t=BFmatch(a,b,n,m);
    for(auto v:t)cout<<v<<endl;
    return 0;
}
```

## Hash

见[[学习/信竞算法/字符串/字符串哈希|字符串哈希]] ，哈希值相同即可

## KMP

见 [[学习/信竞算法/字符串/KMP|KMP]]