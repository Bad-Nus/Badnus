# 定义

定义把一个字符串映射到整数的函数 $f$ 为哈希 (Hash) 函数，称 $f(t)$ 字符串 $t$ 的 Hash 值

定义哈希冲突为两个不同的字符串映射到相同的 Hash 值。

我们主要关心哈希函数的准确率和时间复杂度

1. 准确率我们希望这个函数越接近单射越好，即
	- 哈希冲突概率低
	- 亦或是在题设下应用该函数时，不易产生冲突
2. 在基本保证准确率下，降低哈希函数的实现复杂度
	- 优化实现逻辑
	- 亦或是用准确率可能出错的低复杂度方式，重复运行多次，再合并答案保证正确性概率接近于 1
## 哈希冲突概率
Hash 冲突是指两个不同的字符串映射到相同的 Hash 值。

我们设 Hash 的取值空间（所有可能出现的字符串的数量）为 $d$，计算次数（要计算的字符串数量）为 $n$。

则 Hash 冲突的概率为：

$$
p(n,d) = 1 - \frac{d!}{d^n\left(d-n\right)!} \approx 1 - \exp(-\frac{n(n-1)}{2d} )
$$
### 证明

当 Hash 中每个值生成概率相同时，Hash 不冲突的概率为 (生日悖论)：

$$
\overline{p}(n,d) = 1 \cdot \left (1 - \frac{1}{d} \right) \cdot \left ( 1- \frac{2}{d}\right) \cdots \left ( 1- \frac{n-1}{d}\right)
$$

化简得到：

$$
\begin{aligned}
\overline{p}(n,d) 
& = \frac{d}{d}\cdot \frac{d-1}{d}\cdot \frac{d-2}{d} \cdots \frac{d-n+1}{d}\\
& = \frac{d\cdot (d-1)\cdot (d-2)\cdots(d-n+1)}{d^n}\\
& = \frac{d!}{d^n\left(d-n\right)!}
\end{aligned}
$$

则 Hash 冲突的概率为：

$$
p(n,d) = 1 - \frac{d!}{d^n\left(d-n\right)!}
$$

这个公式还是太复杂了，我们进一步化简。

根据泰勒公式：

$$
\exp(x) = \sum_{k=0}^{\infty}\frac{x^k}{k!}=1+x+\frac{x^2}{2}+\frac{x^3}{6}+\frac{x^4}{24}+\cdots
$$

当 $x$ 为一个极小值时，$\exp(x)$ 趋近于 $1+x$。

将它带入 Hash 不冲突的原始公式：

$$
\overline{p}(n,d) \approx 1 \cdot \exp(-\frac{1}{d}) \cdot \exp(-\frac{2}{d}) \cdots \exp(-\frac{n-1}{d})
$$

化简：

$$
\begin{aligned}
\overline{p}(n,d) & \approx \exp(-\frac{1}{d} - \frac{2}{d} - \cdots -\frac{n-1}{d})\\
&=\exp(-\frac{n(n-1)}{2d} )
\end{aligned}
$$

则 Hash 冲突的概率为：

$$
    p(n,d) \approx 1 - \exp(-\frac{n(n-1)}{2d})
    $$
# 实现

我们受进制数启发，将字符串每一位看做是进制位，转成十进制数，称作**多项式哈希**，对长度为 $l$ 的字符串 $s$ 选择 $b$ 进制，有

$$f(s) = \sum_{i=1}^{l} s[i] \times b^{l-i} \pmod M$$

但绝大部分题目字符串长度足够长的情况下，溢出存储单位 (int, long long 等) 势在必然，解决方式：

1. 高精度，部分题目可行，但高精度复杂度高昂
2. 对复杂度有要求的题目，舍弃一点准确率选择取模。模数大小无关复杂度，我们尽可能取大模数，增大值域来降低哈希冲突概率

这里主要讨论取模哈希，一般分：
1. 大模数哈希：定义一个较大的整数用来取模
2. 自然溢出：利用 C++ 中无符号整数类型溢出等价于取余的性质取模，一般是 ull 的 $2^{64}$
## 卡大模数哈希

注意到这个公式：

$$
p(n,d) \approx 1 - \exp(-\frac{n(n-1)}{2d} )
$$

为了卡掉 Hash，我们要满足一下条件：

1.  $d$ 大于模数。
2.  $1-p(d,n)$ 尽量小。

### 举例 ：

若字符集为 **大小写字母和数字**，模数为 $10^9+7$ 时：

$\log_{62}10^9+7\approx 6$

$p(10^6,62^{6}) \approx 0.9$

所以对于这个范围，我们随机生成 $10^6$ 个长度为 $6$ 的字符串，它们 Hash 值相同的概率高达 $90\%$。

## 卡自然溢出 Hash

Hash 模数太大，上面方法卡不了，需要另一种方法，我们根据 $b$ 来分类讨论。

### B 为偶数

此时 $f(s) = s_1\cdot b^l + s_2\cdot b^{l-1} + \cdots + s_l\cdot b \pmod M$，其中 $M$ 为 $2^{64}$。

容易发现若 $l \ge 64$，$s_i\cdot b^l \equiv 0 \pmod M$。

所以我们只要构造形如：

`aaa...a`

`baa...a`

且长度大于 $64$ 的字符串就能冲突。

### B 为奇数

定义 $!s_i$ 为把 $s_i$ 中所有字符反转。

例：

$s_i = abaab$

$!s_i = babba$

即把 `a` 变成 `b`，把 `b` 变成 `a`。

再定义 $H_i$ 为 $s_i$ 的 Hash 值，$!H_i$ 为 $!s_i$ 的 Hash 值。

不断构造 $s_i = s_{i-1} + !s_{i-1}$。

$s_{12}$ 和 $!s_{12}$ 就是我们要的两个字符串。
#### 推导
首先，有：

$$
\begin{aligned}
H_i = H_{i-1}\cdot base^{2^{i-2}} + !H_{i-1}\\
!H_{i} = !H_{i-1}\cdot base^{2^{i-2}}+H_{i-1}
\end{aligned}
$$

尝试相减：

$$
\begin{aligned}
&H_i - !H_i\\
=\ &H_{i-1}\cdot base^{2^{i-2}} + !H_{i-1}-(!H_{i-1}\cdot base^{2^{i-2}}+H_{i-1})\\
=\ &(H_{i-1}-!H_{i-1})\cdot (base^{2^{i-2}}-1)
\end{aligned}
$$

发现出现了 $2^i$，但是原式太复杂，尝试换元：

设：

$$
\begin{aligned}
f_i = H_i - !H_i\\
g_i = base^{2^{i-2}}-1
\end{aligned}
$$

根据原式得：

$$
\begin{aligned}
f_i &= f_{i-1} \cdot g_i\\
	&=f_1 \cdot g_1 \cdot g_2 \cdots g_{i-1}\\
\end{aligned}
$$

因为 $base^{2^{i-2}}$ 一定是奇数，所以 $g_i$ 一定是偶数。

所以：

$$
2^{i-1} | f_i
$$

但这样太大了，$i-1\ge 64$ 才能卡掉，继续化简：

$$
g_i = base^{2^{i-2}}-1 = (base^{2^{i-3}}-1)\cdot(base^{2^{i-3}}+1)\\
$$

即 $g_i$ 为 $g_{i-1} \cdot c\ (c \equiv 0 \pmod 2)$ 的形式。

所以 $2 | s_1$，$4|s_2$...，即

$$
\begin{aligned}
& 2^i &| g_i\\
&2^1\cdot2^2\cdot2^3\cdots2^{i-1} &| f_i\\
&2^{i(i-1)/2} &| f_i
\end{aligned}
$$

即当 $i=12$ 时就可以使 $2^{64} | H_i - !H_i$ 达到要求。

## 优化

### 多值哈希

使用多个模数不同的哈希进行判断，若存在不同就认为两个字符串不同，否则相同

一般来说，双值哈希就够用了

## 子串哈希

询问子串哈希是 $O(n)$ 的，相当于暴力，多次询问效率低下。

考虑哈希值的性质，记 $f_i(s)$ 为前缀长为 $i$ 的哈希值，那么 $f(s[l,r])=f_r(s)-f(l-1)\times b^{r-l+1}$ 