## DFA 最小化

将 DFA 转化为与其等价的 DFA 中状态数最少的一个

使用 Hopcroft 算法

首先去除无法从 $q_0$ 到达和无法到达 $F$ 的状态

定义两个状态 $u$ 和 $v$ 无法区分当且仅当  
$$ [u \in F] = [v \in F] $$  
且两者所有转移对应相同或无法区分

先将所有状态按是否被接受划分为两个等价类

每次取出一个等价类 $S$ ，使得存在 $u, v \in S$ ，满足存在 $c \in \Sigma$ ，使得 $\delta(u, c) \neq \delta(v, c)$ 。将 $S$ 按 $\delta(s, c) (s \in S)$ 是否与 $\delta(u, c)$ 相同分为两个等价类。直到不存在满足要求的等价类为止

最后将每个等价类作为新 DFA 的一个状态即可，可证这样是最小的

>  此算法可进一步优化:

维护一个还没有被考虑过的等价类的集合 $W$

每次从 $W$ 中取出一个 $X$ ，枚举 $c \in \Sigma$ ，对于所有 $\exists u \in Y, \delta(u, c) \in X$ 
的 $Y$ （建反图找），若其可以划分，则将 $Y$ 分裂为 $A$ 和 $B$ 。若 $Y$ 没被考虑过，则将 $A$ 和 $B$ 放入 $W$ 。否则将较小的一个放入 $W$

这样时间复杂度为  
$$ O(|\Sigma||Q|\log |Q|) $$