# 综论
$\boxed{形式语言理论}\to\boxed{自动机: \boxed{有限状态机}\to\boxed{下推自动机}\to\boxed{图灵机}}$
# 形式语言理论

# 自动机理论

自动机不是算法或数据结构，而是一种**数学模型**
## 基本定义与符号
1. $\varepsilon$ ：空串
2. $\Sigma$ ：字母表
3. $\Sigma^n$ ：所有长为 $n$ 的字母表的集合
4. $\Sigma^*$ ：所有字母表的集合，有 $\Sigma^*=\bigcup_{i=1}^{\infty}\Sigma^i$
5. $L$ : 语言，是 $\Sigma^*$ 的子集
6. $2^S$ ：幂集， $2^S=\{T \vert T \subseteq S\}$
7. $A\times B$ ：笛卡尔积， $A \times B=\{(u,v)\vert u\in A,v\in B\}$
8. $\delta : A\to B$ ：从 $A$ 到 $B$ 的映射
9. $ab$ ：将 $a$ 与 $b$ 顺次连接
10. $a^k$ ：将 $k$ 个 $a$ 顺次连接
## 自动机

一个自动机（Automaton）可以形式化地表示为一个 5-元组（Tuple） $M = \langle \Sigma, \Gamma, Q, \delta, \lambda \rangle$ ，当：

- $\Sigma$ 是一个有限的符号集合，称为自动机的输入字母表；
- $\Gamma$ 是另一个有限的符号集合，称为自动机的输出字母表；
- $Q$ 是一个状态集合；
- $\delta$ 是下一个状态函数或转移函数； $\delta : Q \times \Sigma \to Q$ 将状态输入对映射到后继状态。
- $\lambda$ 是下一个输出函数； $\lambda : Q \times \Sigma \to \Gamma$ 将状态输入对映射到输出。

如果 $Q$ 是有限的，那么 $M$ 是一个有限自动机。
### 输入词

一个自动机读取有限符号 $a_1 a_2 \ldots a_n$ 组成的字符串，当 $a_i \in \Sigma$ ，则这个字符串称为输入词（Input word）。所有输入词的集合用 $\Sigma^*$ 表示。

### 运行

一个状态序列 $q_0, q_1, \ldots, q_n$ ，当 $q_i \in Q$ 并且 $q_i = \delta(q_{i-1}, a_i)$ ，其中 $0 < i \leq n$ ，则一个从状态 $q_0$ 开始的输入 $a_1a_2 \ldots a_n \in \Sigma^*$ 为自动机的一次运行（Run）。

换句话说，一开始自动机在初始状态 $q_0$ ，并接收输入 $a_1$ 。为了 $a_1$ 和每个接下来的 $a_i$ 处于输入字符串中，自动机会选择下一个状态 $q_i$ （根据转移函数 $\delta(q_{i-1}, a_i)$ 获取），直到最后一个符号 $a_n$ 被读取，使机器处于运行的最终状态 $q_n$ 。

类似地，每一步，自动机会根据输出函数发出一个输出符号 $\lambda(q_{i-1}, a_i)$ 。

### 接受器

为了用形式语言理论来研究自动机，可以将自动机看作一个接受器（Acceptor），代替输出字母表和函数 $\Gamma$ 和 $\lambda$ ：

- $q_0 \in Q$ ，一个指定的开始状态，和
- $F$ ，一个 $Q$ （即 $F \subseteq Q$ ）的状态集合称为接受状态。

这允许定义以下内容：

### 接受词

对于自动机的输入单词 $w = a_1a_2 \ldots a_n \in \Sigma^*$ ，如果 $\delta(q_0, w) \in F$ ，换句话说，如果在消耗了整个字符串 $w$ 之后该机器仍然处于可接受状态，那么 $w$ 是一个接受词（Accepting word）。

### 已识别语言

语言 $L \subseteq \Sigma^*$ 能被自动机识别，则由所有已被自动机接受的单词组成的集合被叫做已识别语言（Recognized Language）。

### 可识别语言

可识别语言（Recognizable Languages）是一些自动机识别的语言集合。对于有限自动机，可识别的语言是正则语言（Regular Languages）。对于不同类型的自动机，可识别的语言是不同的。

### 确定性和非确定性

- **确定性**：对于给定的当前状态和输入符号，如果自动机只能跳转到一个且只有一个状态，则它是确定性自动机（Deterministic Automaton）。
- **非确定性**：一种自动机，在读取输入符号后，可能会跳转到许多状态中的任何一个，如其转换关系所许可的那样。请注意，术语转换函数被转换关系取代：自动机不确定地决定跳入允许的选择之一。这样的自动机称为非确定性自动机（Nondeterministic Automata）。


## 确定有限状态自动机（DFA）

DFA ：$(\Sigma,Q,q_0,F,\delta)$ ，其中：

1. $\Sigma$ ：**字母表**
2. $Q$ ：**有穷**的**状态集合**
3. $q_0\in Q$ ：**起始状态**
4. $F\in Q$ ：**接受状态集合**
5. $\delta$ ：$(Q \times \Sigma)\to Q$ ：**转移函数，接受状态二元组并返回新状态**

对 $s=s_1s_2\ldots s_n$ 和 DFA $M$ ，若 $\exists \{r_0,r_1\ldots r_n\}$ ，使得：$q_0=r_0,\forall 1 \leq i \leq n(r_i = \delta(r_{i-1}, s_i)),且r_n \in F$ ，则称该自动机 $M$ 可接受 $s$

对 DFA $M$ ，令所有 $M$ 可以接受的**语言**(所有字符串的集合) 为 $L(M)$ ，则程 $M$ 可识别语言 $L(M)$

一个语言可被 $DFA$ 识别称其为正则语言

## 非确定有限状态自动机 （NFA）

NFA : $(\Sigma, Q, q_0, F, \delta)$ ，其中:

前四项与 DFA 相同，第五项 $\delta : Q \times \Sigma \to 2^Q$ 为转移函数，接受参数为一个二元组，返回一个状态的集合

对于字符串 $s = s_1 s_2 \cdots s_n$ 和 NFA $M$，若 $\exists r_0, r_1, \cdots, r_n$ ，使得 $q_0 = r_0$ , $\forall 1 \leq i \leq n (r_i \in \delta(r_{i-1}, s_i))$ , $r_n \in F$ ，则称该自动机 $M$ 可以接受 $s$

对于 NFA $M$ ，令所有 $M$ 可以接受的字符串的集合为 $L(M)$ ，则称 $M$ 可以识别语言 $L(M)$

NFA - $\epsilon$ 为带空移动的不确定有限状态自动机，其转移函数为 $\delta : Q \times (\Sigma \cup \{\epsilon\}) \to Q$ ，其余不变

## 定理

1. $\forall \boxed{M_1\in (NFA - \epsilon)},\exists \boxed{M_2\in (NFA)},使 L(M_1)=L(M_2)$
2. $\forall \boxed{M_1\in (NFA)},\exists \boxed{M_2\in (DFA)},使 L(M_1)=L(M_2)$
## 定理证明

1. 令 $\delta$ 为 NFA- $\epsilon$ 的转移函数， $\delta'$ 为新 NFA 的转移函数，则：

$$\delta'(q, c) = \delta(q, c) \cup \delta(\delta(q, \varepsilon), c) \cup \delta(\delta(\delta(q, \varepsilon), \varepsilon), c) \cup \cdots$$

（虽然有无穷项，但其并为有限集）

2. 将 `NFA` 变为 `DFA` 的算法称为子集构造法

流程为：

- 将初始状态加入 `DFA` 但不标记
- 取出 `DFA` 中一个没有标记的状态 $q$ ，加上标记
- 将其转移 $\delta'(q, c)$ 设为原 `NFA` 中的 $\delta(q, c)$ 对应的状态（即新增 $2^{|Q|}$ 个状态，分别对应 $2^Q$ 中的每个，每个转移向其对应集合中的元素）
- 将 `NFA` 的 $\delta(q, c)$ 中所有还没有加入 `DFA` 的加入 `DFA` （但不标记）
- 重复以上三步

正确性显然，但状态数为 $O(2^{|Q|})$ 的，难以接受

因此若要判断某字符串能否被某 `NFA` 识别，可以直接在原 `NFA` 上跑（而不是建出 `DFA`）

具体流程为维护一个集合 $S$ ，初始仅含 $q_0$ ，每次转移一个字符 $s_i$ ，则令 $S \leftarrow \bigcup_{u \in S} \delta(u, s_i)$ ，若最终的 $S$ 与 $F$ 交不为空则可以识别，反之不能

直接实现为 $O(|S||Q|^2)$ 的（其中 $S$ 为待识别字符串），若用 `bitset` 则可以变为 $O\left(\frac{|S||Q|^2}{\omega}\right)$ ，虽然远小于原本的指数复杂度，但仍然较慢

还可以用类似四毛子的方式继续优化

将 `NFA` 分块，设每块大小为 $T$

对于每个块，枚举 $2^T$ 个子集和 $|\Sigma|$ 个字符，处理出每个子集在各种字符下的转移，这部分时间复杂度为

$$O\left(2^T|\Sigma|\frac{|Q|}{T}\cdot\frac{|Q|}{\omega}\right)=O\left(\frac{|Q|^22^T|\Sigma|}{T\omega}\right)$$

转移时，直接将 $\frac{|Q|}{T}$ 个块的预处理结果拼起来即可，这部分时间复杂度

$$O\left(|S|\cdot\frac{|Q|}{T}\cdot\frac{|Q|}{\omega}\right)=O\left(\frac{|S||Q|^2}{T\omega}\right)$$

总时间复杂度 $O\left(\frac{|Q|^22^T|\Sigma|}{T\omega}+\frac{|S||Q|^2}{T\omega}\right)$

## DFA 最小化

将 DFA 转化为与其等价的 DFA 中状态数最少的一个

使用 Hopcroft 算法

首先去除无法从 $q_0$ 到达和无法到达 $F$ 的状态

定义两个状态 $u$ 和 $v$ 无法区分当且仅当  
$$ [u \in F] = [v \in F] $$  
且两者所有转移对应相同或无法区分

先将所有状态按是否被接受划分为两个等价类

每次取出一个等价类 $S$ ，使得存在 $u, v \in S$ ，满足存在 $c \in \Sigma$ ，使得 $\delta(u, c) \neq \delta(v, c)$ 。将 $S$ 按 $\delta(s, c) (s \in S)$ 是否与 $\delta(u, c)$ 相同分为两个等价类。直到不存在满足要求的等价类为止

最后将每个等价类作为新 DFA 的一个状态即可，可证这样是最小的

**此算法可进一步优化**:

维护一个还没有被考虑过的等价类的集合 $W$

每次从 $W$ 中取出一个 $X$ ，枚举 $c \in \Sigma$ ，对于所有 $\exists u \in Y, \delta(u, c) \in X$ 
的 $Y$ （建反图找），若其可以划分，则将 $Y$ 分裂为 $A$ 和 $B$ 。若 $Y$ 没被考虑过，则将 $A$ 和 $B$ 放入 $W$ 。否则将较小的一个放入 $W$

这样时间复杂度为  
$$ O(|\Sigma||Q|\log |Q|) $$