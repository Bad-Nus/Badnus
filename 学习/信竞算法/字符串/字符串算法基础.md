# 综论
$\boxed{形式语言理论}\to\boxed{自动机: \boxed{有限状态机}\to\boxed{下推自动机}\to\boxed{图灵机}}$
# 形式语言理论

# 自动机理论

自动机不是算法或数据结构，而是一种**数学模型**
## 基本定义与符号
1. $\varepsilon$ ：空串
2. $\Sigma$ ：字母表
3. $\Sigma^n$ ：所有长为 $n$ 的字母表的集合
4. $\Sigma^*$ ：所有字母表的集合，有 $\Sigma^*=\bigcup_{i=1}^{\infty}\Sigma^i$
5. $L$ : 语言，是 $\Sigma^*$ 的子集
6. $2^S$ ：幂集， $2^S=\{T \vert T \subseteq S\}$
7. $A\times B$ ：笛卡尔积， $A \times B=\{(u,v)\vert u\in A,v\in B\}$
8. $\delta : A\to B$ ：从 $A$ 到 $B$ 的映射
9. $ab$ ：将 $a$ 与 $b$ 顺次连接
10. $a^k$ ：将 $k$ 个 $a$ 顺次连接
## 确定有限状态自动机（DFA）

DFA ：$(\Sigma,Q,q_0,F,\delta)$ ，其中：

1. $\Sigma$ ：**字母表**
2. $Q$ ：**有穷**的**状态集合**
3. $q_0\in Q$ ：**起始状态**
4. $F\in Q$ ：**接受状态集合**
5. $\delta$ ：$(Q \times \Sigma)\to Q$ ：**转移函数，接受状态二元组并返回新状态**

对 $s=s_1s_2\ldots s_n$ 和 DFA $M$ ，若 $\exists \{r_0,r_1\ldots r_n\}$ ，使得：$q_0=r_0,\forall 1 \leq i \leq n(r_i = \delta(r_{i-1}, s_i)),且r_n \in F$ ，则称该自动机 $M$ 可接受 $s$

对 DFA $M$ ，令所有 $M$ 可以接受的**语言**(所有字符串的集合) 为 $L(M)$ ，则程 $M$ 可识别语言 $L(M)$

一个语言可被 $DFA$ 识别称其为正则语言

## 非确定有限状态自动机 （NFA）

NFA : $(\Sigma, Q, q_0, F, \delta)$ ，其中:

前四项与 DFA 相同，第五项 $\delta : Q \times \Sigma \to 2^Q$ 为转移函数，接受参数为一个二元组，返回一个状态的集合

对于字符串 $s = s_1 s_2 \cdots s_n$ 和 NFA $M$，若 $\exists r_0, r_1, \cdots, r_n$ ，使得 $q_0 = r_0$ , $\forall 1 \leq i \leq n (r_i \in \delta(r_{i-1}, s_i))$ , $r_n \in F$ ，则称该自动机 $M$ 可以接受 $s$

对于 NFA $M$ ，令所有 $M$ 可以接受的字符串的集合为 $L(M)$ ，则称 $M$ 可以识别语言 $L(M)$

NFA - $\epsilon$ 为带空移动的不确定有限状态自动机，其转移函数为 $\delta : Q \times (\Sigma \cup \{\epsilon\}) \to Q$ ，其余不变

## 定理

1. $\forall \boxed{M_1\in (NFA - \epsilon)},\exists \boxed{M_2\in (NFA)},使 L(M_1)=L(M_2)$
2. $\forall \boxed{M_1\in (NFA)},\exists \boxed{M_2\in (DFA)},使 L(M_1)=L(M_2)$
## 定理证明

1. 令 $\delta$ 为 NFA- $\epsilon$ 的转移函数， $\delta'$ 为新 NFA 的转移函数，则：

$$\delta'(q, c) = \delta(q, c) \cup \delta(\delta(q, \varepsilon), c) \cup \delta(\delta(\delta(q, \varepsilon), \varepsilon), c) \cup \cdots$$

（虽然有无穷项，但其并为有限集）

2. 将 `NFA` 变为 `DFA` 的算法称为子集构造法

流程为：

- 将初始状态加入 `DFA` 但不标记
- 取出 `DFA` 中一个没有标记的状态 $q$ ，加上标记
- 将其转移 $\delta'(q, c)$ 设为原 `NFA` 中的 $\delta(q, c)$ 对应的状态（即新增 $2^{|Q|}$ 个状态，分别对应 $2^Q$ 中的每个，每个转移向其对应集合中的元素）
- 将 `NFA` 的 $\delta(q, c)$ 中所有还没有加入 `DFA` 的加入 `DFA` （但不标记）
- 重复以上三步

正确性显然，但状态数为 $O(2^{|Q|})$ 的，难以接受

因此若要判断某字符串能否被某 `NFA` 识别，可以直接在原 `NFA` 上跑（而不是建出 `DFA`）

具体流程为维护一个集合 $S$ ，初始仅含 $q_0$ ，每次转移一个字符 $s_i$ ，则令 $S \leftarrow \bigcup_{u \in S} \delta(u, s_i)$ ，若最终的 $S$ 与 $F$ 交不为空则可以识别，反之不能

直接实现为 $O(|S||Q|^2)$ 的（其中 $S$ 为待识别字符串），若用 `bitset` 则可以变为 $O\left(\frac{|S||Q|^2}{\omega}\right)$ ，虽然远小于原本的指数复杂度，但仍然较慢

还可以用类似四毛子的方式继续优化

将 `NFA` 分块，设每块大小为 $T$

对于每个块，枚举 $2^T$ 个子集和 $|\Sigma|$ 个字符，处理出每个子集在各种字符下的转移，这部分时间复杂度为

$$O\left(2^T|\Sigma|\frac{|Q|}{T}\cdot\frac{|Q|}{\omega}\right)=O\left(\frac{|Q|^22^T|\Sigma|}{T\omega}\right)$$

转移时，直接将 $\frac{|Q|}{T}$ 个块的预处理结果拼起来即可，这部分时间复杂度

$$O\left(|S|\cdot\frac{|Q|}{T}\cdot\frac{|Q|}{\omega}\right)=O\left(\frac{|S||Q|^2}{T\omega}\right)$$

总时间复杂度 $O\left(\frac{|Q|^22^T|\Sigma|}{T\omega}+\frac{|S||Q|^2}{T\omega}\right)$

## DFA 最小化

将 DFA 转化为与其等价的 DFA 中状态数最少的一个

使用 Hopcroft 算法

首先去除无法从 $q_0$ 到达和无法到达 $F$ 的状态

定义两个状态 $u$ 和 $v$ 无法区分当且仅当  
$$ [u \in F] = [v \in F] $$  
且两者所有转移对应相同或无法区分

先将所有状态按是否被接受划分为两个等价类

每次取出一个等价类 $S$ ，使得存在 $u, v \in S$ ，满足存在 $c \in \Sigma$ ，使得 $\delta(u, c) \neq \delta(v, c)$ 。将 $S$ 按 $\delta(s, c) (s \in S)$ 是否与 $\delta(u, c)$ 相同分为两个等价类。直到不存在满足要求的等价类为止

最后将每个等价类作为新 DFA 的一个状态即可，可证这样是最小的

>  此算法可进一步优化:

维护一个还没有被考虑过的等价类的集合 $W$

每次从 $W$ 中取出一个 $X$ ，枚举 $c \in \Sigma$ ，对于所有 $\exists u \in Y, \delta(u, c) \in X$ 
的 $Y$ （建反图找），若其可以划分，则将 $Y$ 分裂为 $A$ 和 $B$ 。若 $Y$ 没被考虑过，则将 $A$ 和 $B$ 放入 $W$ 。否则将较小的一个放入 $W$

这样时间复杂度为  
$$ O(|\Sigma||Q|\log |Q|) $$