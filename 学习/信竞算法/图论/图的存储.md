## 直接存边
直接存边，当需要从点出发找邻点时效率低下：
```cpp
struct nd{
	int x,y;
};
vector<nd> e;
```
## 邻接矩阵
当没有重边时可以用邻接矩阵存，本质是一个 $n\times n$ 的表格，表示第 $i$ 点到第 $j$ 点是否有边及其边权，如下方法空间复杂度逐渐降低。
### 普通：
空间大，在仅询问两点之间是否有边时快，在遍历时慢

- 有边权
```cpp
int e[N][N];
//或vector<int> e[N]
```

- 无边权
```cpp
bool e[N][N];
//或vector<bool> e[N]
```
### Vector 优化：
仅存有边的点，空间更小

- 有边权
```cpp
struct nd{
  int to,w;
}
vector<nd> e[N];
```
- 无边权
```cpp
vector<int> e[N];
```
## 邻接表
每个点建一条链，链上存有边的点有哪些及其边权，相当于邻接矩阵的 vector 优化。
## 链式前向星
邻接表的链表优化，把多个点的链缩成一条链。
```cpp
const int N=1e5+1;
int pre[N],h[2*N],nxt[2*N],idx;//n为点数,m为边数
void add(int x,int y){//加边
	h[++idx]=y;
	nxt[idx]=pre[x];
	pre[x]=idx;
}
int main(){
  for (int i = pre[u]; i; i = nxt[i]) { //图的遍历
    int v = h[i];//从u到v
  }
  return 0;
}
```