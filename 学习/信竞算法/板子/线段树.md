---
tags:
  - 板子
---
# 线段树加
[例题](https://www.luogu.com.cn/problem/P3372)
```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
#define mid ((pl+pr)>>1)
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
using namespace std;
typedef long long ll;
const int N=1e6+1;
ll tree[N],a[N],add[N],z;
int n,m,op,x,y;
void pushup(int p){tree[p]=tree[ls(p)]+tree[rs(p)];}
void pushdown(int p,int pl,int pr){
    tree[ls(p)]=tree[ls(p)]+add[p]*(mid-pl+1);
    tree[rs(p)]=tree[rs(p)]+add[p]*(pr-mid);
    add[ls(p)]=add[ls(p)]+add[p];
    add[rs(p)]=add[rs(p)]+add[p];
    add[p]=0;
}
void build(int p=1,int pl=1,int pr=n){
    if(pl==pr)return tree[p]=a[pl],void();
    build(ls(p),pl,mid),build(rs(p),mid+1,pr),pushup(p);
}
void updadd(int l,int r,ll d,int p=1,int pl=1,int pr=n){
    if(l>pr||pl>r)return;
    if(l<=pl&&pr<=r)return tree[p]=tree[p]+(pr-pl+1)*d,add[p]=add[p]+d,void();
    pushdown(p,pl,pr),updadd(l,r,d,ls(p),pl,mid),updadd(l,r,d,rs(p),mid+1,pr),pushup(p);
}
ll query(int l,int r,int p=1,int pl=1,int pr=n){
    if(l>pr||pl>r)return 0;
    if(l<=pl&&pr<=r)return tree[p];
    return pushdown(p,pl,pr),(query(l,r,ls(p),pl,mid)+query(l,r,rs(p),mid+1,pr));
}
int main(){
    cin>>n>>m;
    rep(i,1,n)cin>>a[i];
    build();
    while(m--){
        cin>>op>>x>>y;
        if(op==1)cin>>z,updadd(x,y,z);
        else cout<<query(x,y)<<endl;
    }
    return 0;
}
```

# 线段树加乘
[例题](https://www.luogu.com.cn/problem/P3373)
```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
#define mid ((pl+pr)>>1)
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
using namespace std;
const int N=1e6+1;
typedef long long ll;
ll a[N],tree[N],add[N],mul[N],mod,z;
int n,m,op,x,y;
void pushup(int p){tree[p]=(tree[ls(p)]+tree[rs(p)])%mod;}
void pushdown(int p,int pl,int pr){
    tree[ls(p)]=(tree[ls(p)]*mul[p]+add[p]*(mid-pl+1))%mod;
    tree[rs(p)]=(tree[rs(p)]*mul[p]+add[p]*(pr-mid))%mod;
    mul[ls(p)]=(mul[ls(p)]*mul[p])%mod;
    mul[rs(p)]=(mul[rs(p)]*mul[p])%mod;
    add[ls(p)]=(add[ls(p)]*mul[p]+add[p])%mod;
    add[rs(p)]=(add[rs(p)]*mul[p]+add[p])%mod;
    mul[p]=1,add[p]=0;
}
void build(int p=1,int pl=1,int pr=n){
    mul[p]=1;
    if(pl==pr)return tree[p]=a[pl],void();
    build(ls(p),pl,mid),build(rs(p),mid+1,pr),pushup(p);
}
void updmul(int l,int r,ll d,int p=1,int pl=1,int pr=n){
    if(l>pr||pl>r)return;
    if(l<=pl&&pr<=r)return tree[p]=(tree[p]*d)%mod,mul[p]=(mul[p]*d)%mod,add[p]=(add[p]*d)%mod,void();
    pushdown(p,pl,pr),updmul(l,r,d,ls(p),pl,mid),updmul(l,r,d,rs(p),mid+1,pr),pushup(p);
}
void updadd(int l,int r,ll d,int p=1,int pl=1,int pr=n){
    if(l>pr||pl>r)return;
    if(l<=pl&&pr<=r)return tree[p]=(tree[p]+d*(pr-pl+1))%mod,add[p]=(add[p]+d)%mod,void();
    pushdown(p,pl,pr),updadd(l,r,d,ls(p),pl,mid),updadd(l,r,d,rs(p),mid+1,pr),pushup(p);
}
ll query(int l,int r,int p=1,int pl=1,int pr=n){
    if(l>pr||pl>r)return 0;
    if(l<=pl&&pr<=r)return tree[p];
    return pushdown(p,pl,pr),(query(l,r,ls(p),pl,mid)+query(l,r,rs(p),mid+1,pr))%mod;
}
int main(){
    cin>>n>>m>>mod;
    rep(i,1,n)cin>>a[i];
    build();
    while(m--){
        cin>>op>>x>>y;
        if(op==1)cin>>z,updmul(x,y,z);
        else if(op==2)cin>>z,updadd(x,y,z);
        else cout<<query(x,y)<<endl;
    }
    return 0;
}
```

# Zosok 线段树加乘

```cpp
#include<bits/stdc++.h>
typedef long long LL;
LL rd(){
	LL r=0,f=1;int c=getchar();
	while((c<'0'||c>'9')&&c!='-')c=getchar();
	if(c=='-'){
		f=-1,c=getchar();
	}
	while(c>='0'&&c<='9'){
		r=r*10+c-'0';
		c=getchar();
	}
	return r*f;
}

const int MAXN=1e5+10;
LL N,Q,M;
#define Lc(i) ((i)<<1)
#define Rc(i) (((i)<<1)|1)
struct TAG{//fis:c,sec:add
	LL add,c;
	void u(const TAG& b){
		c*=b.c,add*=b.c;
		c%=M,add%=M;
		add+=b.add;
		c%=M,add%=M;//a*c*c2+add*c2+add2
	}
	void nul(){
		add=0,c=1;
	}
	TAG(){nul();}
	TAG(LL _a,LL _b){
		add=_a%M,c=_b%M;
	}
};
struct DAT{
	LL v,len=-1;
	void u(const TAG& b){
		v*=b.c;
		v%=M;
		v+=b.add*len;
		v%=M;
	}
	DAT operator+(DAT b){
		return {(v+b.v)%M,len==-1?(b.len==-1?(std::cerr<<'!',-1):b.len):len};
	}
	DAT():v(0){}
	DAT(LL _a,LL _b):v(_a),len(_b){}
};



struct NODE{
	TAG lazy;
	DAT dat;
	void u(const TAG& b){
		dat.u(b);
		lazy.u(b);
	}
}T[4*MAXN];
void pd(int i){
	T[Lc(i)].u(T[i].lazy);
	T[Rc(i)].u(T[i].lazy);
	T[i].lazy.nul();
}
void up(int i){
	int tl=T[i].dat.len;
	T[i].dat=T[Lc(i)].dat+T[Rc(i)].dat;
	T[i].dat.len=tl;
}
void un(LL l,LL r,const TAG& t,LL L=1,LL R=N,int i=1){
	if(l<=L&&R<=r){
		T[i].u(t);
		return;
	}else{
		pd(i);
		LL mid=(L+R)>>1;
		if(l<=mid){
			un(l,r,t,L,mid,Lc(i));
		}
		if(r>mid){
			un(l,r,t,mid+1,R,Rc(i));
		}
		up(i);
	}
}
DAT ask(LL l,LL r,LL L=1,LL R=N,int i=1){
	if(l<=L&&R<=r){
		return T[i].dat;
	}else{
		pd(i);
		LL mid=(L+R)>>1;
		DAT ret;
		if(l<=mid){
			ret=ret+ask(l,r,L,mid,Lc(i));
		}
		if(r>mid){
			ret=ret+ask(l,r,mid+1,R,Rc(i));
		}
		return ret;
	}
}
void initT(LL l,LL r,int i){
	T[i].dat.len=r-l+1;//T[i].dat.deb=i;
	// std::cerr<<'['<<T[i].dat.len<<']';
	if(l==r){
		T[i].dat.v=rd();
		return;
	}
	LL mid=(l+r)/2;
	initT(l,mid,Lc(i));
	initT(mid+1,r,Rc(i));
	up(i);
}
//LL* display(int l,int r){
//	LL* ret=new LL[r-l+10];
//	for(int i=0;i<=r-l;i++){
//		ret[i]=ask(l+i,l+i).v;
//	}
//	return ret;
//}
int main(){
	N=rd(),Q=rd(),M=rd();
	initT(1,N,1);
	while(Q--){
		int op=rd();
		switch(op){
			case 1:{
				LL x=rd(),y=rd(),k=rd();
				un(x,y,{0,k});
				break;
			}
			case 2:{
				LL x=rd(),y=rd(),k=rd();
				un(x,y,{k,1});
				break;
			}
			case 3:{
				LL x=rd(),y=rd();
				printf("%lld\n",ask(x,y).v%M);
				break;
			}
		}
	}
}

```

# 可持久化线段树

[例题](https://www.luogu.com.cn/problem/P3919)

```cpp
#include<bits/stdc++.h>
#define rep(u,x,y) for(int u=x;u<=y;++u)
#define mid ((pl+pr)>>1)
#define gc getchar
#define pc putchar
using namespace std;
const int N=1e6+1;
int n,q,ver,op,p,c;
int a[N];
int read(){
    int x=0,w=1;
    char ch=gc();
    while(ch<'0'||ch>'9')(ch=='-')&&(w=-1,0),ch=gc();
    while(ch>='0'&&ch<='9')x=(x*10)+(ch^48),ch=gc();
    return x*w;
} 
void wrt(int x){
    if(x<0)pc('-'),x=-x;
    if(x>9)wrt(x/10);
    pc(x%10^48);
}
struct PST{//PersistentSegmentTree
    struct nd{
        int l,r,v;
    }tree[N*30];
    int id,root[N];
    int insert(int u){
        tree[++id]=tree[u];
        return id;
    }
    int build(int u,int pl=1,int pr=n){
        u=++id;
        if(pl==pr)return tree[u].v=a[pl],u;
        tree[u].l=build(tree[u].l,pl,mid);
        tree[u].r=build(tree[u].r,mid+1,pr);
        return u;
    }
    int modify(int u,int p,int val,int pl=1,int pr=n){
        u=insert(u);
        if(pl==pr)return tree[u].v=val,u;
        if(p<=mid)tree[u].l=modify(tree[u].l,p,val,pl,mid);
        else tree[u].r=modify(tree[u].r,p,val,mid+1,pr);
        return u;
    }
    int query(int u,int p,int pl=1,int pr=n){
        if(pl==pr)return tree[u].v;
        if(p<=mid)return query(tree[u].l,p,pl,mid);
        else return query(tree[u].r,p,mid+1,pr);
    }
}T;
int main(){
    n=read(),q=read();
    rep(i,1,n)a[i]=read();
    T.root[0]=T.build(0);
    rep(t,1,q){
        ver=read(),op=read();
        if(op==1)p=read(),c=read(),T.root[t]=T.modify(T.root[ver],p,c);
        else p=read(),wrt(T.query(T.root[t]=T.root[ver],p)),pc('\n');
    }
    return 0;
}
```