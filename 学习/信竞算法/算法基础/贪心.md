# 贪心

即程序每步都**贪心**地选取**目前看似最优的解**，不考虑**后效性**

编码简单也因此具局限性，适用前提是证明贪心策略的正确性

适用范围中最常见的问题为**最优子结构问题**，即问题每部分最优解都可以由其子问题最优解递推而得

# 贪心证明

贪心有如下证明方法：
1. **反证法**： 若交换方案中**任意的/相邻的**两个元素后，答案不更优，可推定目前的解已是最优解。
2. **归纳法**：先得出边界情况的最优解 $F_1$ ，然后证明：对每个 $n$ ，$F_{n+1}$ 都可由 $F_{n}$ 推导出。
# 悔贪

贪心本身不反悔，取目前最优，不回首修改过去贡献，也不考虑是否未来最优，因此有时无法取得全局最优

但，若贪心过程可记录**历史每次贡献**，且对**每次记录的历史贡献** $p$ 都可以找到一个**逆贡献** $p^{-1}$ 来抵消，便可以通过探测到当前贪心策略劣处后回溯去劣取优，进而保证全局最优。

称为**反悔贪心**，简称**悔贪**，思路是无论当前的选项是否最优都接受，然后未来进行比较，若选择后不是最优，则反悔舍弃，否则正式接受。如此往复。

悔贪的一般策略为用优先队列维护贡献，用 $\boxed{可选队外贡献}$ 替换 $\boxed{队中最劣且劣于前者的贡献}$ 即可，称为**反悔堆**。

悔贪的更复杂策略，建立实现对应策略的**反悔自动机**即可。