---
tags:
  - 板子
---
# 快速幂加求单逆

```cpp
typedef long long ll;
ll mi(ll x, ll y,ll p) {
    ll res = 1;
    while (y) {
        if (y & 1)res = res * x % p;
        x = x * x % p,y >>= 1;
    }
    return res%p;
}
ll invr(ll a,ll p){return mi(a,p-2,p);}
```

# 拓展欧几里得求逆

```cpp
typedef long long ll;
ll x,y;
ll exgcd(ll a,ll b,ll &x,ll &y){
	if(!b)return x=1,y=0,a;
	int d=exgcd(b,a%b,y,x);
	y-=(a/b)*x;
	return d;
}
ll inver(ll a,ll p){return exgcd(a,p,x,y),(x%p+p)%p;}
```

# 线性求逆

```cpp
typedef long long ll;
const int N=1e6+1;
ll inv[N];
void init(int p){inv[0]=0,inv[1]=1;for(int i=2;i<=n;++i)inv[i] = (p - p / i) * inv[p % i] % p;}
```
# 任意 n 个数逆

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e6+1;
ll n,m,x,y,inv[N];
//快速幂 
ll mi(ll x, ll y,ll p) {
    ll res = 1;
    while (y) {
        if (y & 1)res = res * x % p;
        x = x * x % p,y >>= 1;
    }
    return res%p;
}
ll invr(ll a,ll p){return mi(a,p-2,p);}
//拓展gcd 
ll exgcd(ll a,ll b,ll &x,ll &y){
	if(!b)return x=1,y=0,a;
	int d=exgcd(b,a%b,y,x);
	y-=(a/b)*x;
	return d;
}
ll inver(ll a,ll p){return exgcd(a,p,x,y),(x%p+p)%p;}
/*线性*/
void init(int p){inv[0]=0,inv[1]=1;for(int i=2;i<=n;++i)inv[i] = (p - p / i) * inv[p % i] % p;}
/*任意数*/
ll a[N],s[N]={1},sinv[N],sv[N];
void solve(int n,int p){
	for (int i = 1; i <= n; ++i) s[i] = s[i - 1] * a[i] % p;
	sv[n] = mi(s[n], p - 2,p)/*或exgcd求逆元*/;
	for (int i = n; i >= 1; --i) sv[i - 1] = sv[i] * a[i] % p;
	for (int i = 1; i <= n; ++i) sinv[i] = sv[i] * s[i - 1] % p;	
}
int main(){
	cin>>n>>m,init(m);
	for(int i=1;i<n;++i)if(inv[i]!=inver(i,m)||inv[i]!=mi(i,m-2,m))cout<<"Ops! "<<i<<' '<<inv[i]<<' '<<inver(i,m)<<' '<<mi(i,m-2,m)<<endl;
	return 0;
}
```
# 线性求逆加 O (1) 预处理 1~p 组合数加卢卡斯 (仅取模 mod 可用)
```cpp
const int N=1e6+1;typedef long long ll;
ll s[N],is[N];
ll n,x,y,inv[N]={0,1},mod,p;
ll mi(ll x, ll y,ll mod) {
    ll res = 1;
    while (y) {
        if (y & 1)res = res * x % mod;
        x = x * x % mod,y >>= 1;
    }
    return res%mod;
}
void init(ll p,ll mod){
//	for(int i=2;i<m;++i)inv[i] = (mod - mod / i) * inv[mod % i] % mod,s[i]=s[i-1]*i,is[i]=is[i-1]*inv[i];
	s[0]=is[0]=1;
	for(ll i=1;i<=p;++i)s[i]=s[i-1]*i%mod;
	is[p]=(s[p],mod-2,mod);
	for(int i=p-1;i>=1;--i)is[i]=is[i+1]*(i+1)%mod;
}
ll C(int x,int y,int mod){return s[x]*is[y]%mod*is[x-y]%mod;}
ll lucas(ll a, ll b, ll p)
{
    if(a < p && b < p) return C(a, b, p);
    return C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}
```
